{"version":3,"sources":["webpack:///chem-equilibrium/./~/ml-array-utils/src/getEquallySpaced.js","webpack:///chem-equilibrium/webpack/universalModuleDefinition","webpack:///chem-equilibrium/webpack/bootstrap 0642bb1227aeb3e22563","webpack:///chem-equilibrium/./~/ml-matrix/src/matrix.js","webpack:///chem-equilibrium/./~/ml-matrix/src/views/base.js","webpack:///chem-equilibrium/./~/ml-matrix/src/util.js","webpack:///chem-equilibrium/./~/buffer/index.js","webpack:///chem-equilibrium/./~/ml-matrix/src/dc/util.js","webpack:///chem-equilibrium/./~/ml-stat/index.js","webpack:///chem-equilibrium/./src/core/Equilibrium.js","webpack:///chem-equilibrium/./~/deepcopy/index.js","webpack:///chem-equilibrium/./~/deepcopy/lib/polyfill.js","webpack:///chem-equilibrium/./~/ml-matrix/src/abstractMatrix.js","webpack:///chem-equilibrium/./~/ml-matrix/src/dc/lu.js","webpack:///chem-equilibrium/./~/ml-matrix/src/dc/svd.js","webpack:///chem-equilibrium/./~/ml-matrix/src/index.js","webpack:///chem-equilibrium/./~/ml-stat/array.js","webpack:///chem-equilibrium/./src/helpers/Helper.js","webpack:///chem-equilibrium/./src/helpers/Serie.js","webpack:///chem-equilibrium/./data/data.json","webpack:///chem-equilibrium/./src/core/Equation.js","webpack:///chem-equilibrium/./src/core/EquationSet.js","webpack:///chem-equilibrium/./src/core/NewtonRaphton.js","webpack:///chem-equilibrium/./src/index.js","webpack:///chem-equilibrium/./src/util/random.js","webpack:///chem-equilibrium/./~/base64-js/index.js","webpack:///chem-equilibrium/./~/debug/src/browser.js","webpack:///chem-equilibrium/./~/debug/src/debug.js","webpack:///chem-equilibrium/./~/deepcopy/lib/copy.js","webpack:///chem-equilibrium/./~/deepcopy/lib/index.js","webpack:///chem-equilibrium/./~/ieee754/index.js","webpack:///chem-equilibrium/./~/isarray/index.js","webpack:///chem-equilibrium/./~/ml-array-utils/src/ArrayUtils.js","webpack:///chem-equilibrium/./~/ml-array-utils/src/index.js","webpack:///chem-equilibrium/./~/ml-array-utils/src/snv.js","webpack:///chem-equilibrium/./~/ml-matrix/src/dc/cholesky.js","webpack:///chem-equilibrium/./~/ml-matrix/src/dc/evd.js","webpack:///chem-equilibrium/./~/ml-matrix/src/dc/qr.js","webpack:///chem-equilibrium/./~/ml-matrix/src/decompositions.js","webpack:///chem-equilibrium/./~/ml-matrix/src/symbol-species.js","webpack:///chem-equilibrium/./~/ml-matrix/src/views/column.js","webpack:///chem-equilibrium/./~/ml-matrix/src/views/flipColumn.js","webpack:///chem-equilibrium/./~/ml-matrix/src/views/flipRow.js","webpack:///chem-equilibrium/./~/ml-matrix/src/views/row.js","webpack:///chem-equilibrium/./~/ml-matrix/src/views/selection.js","webpack:///chem-equilibrium/./~/ml-matrix/src/views/sub.js","webpack:///chem-equilibrium/./~/ml-matrix/src/views/transpose.js","webpack:///chem-equilibrium/./~/ml-stat/matrix.js","webpack:///chem-equilibrium/./~/ms/index.js","webpack:///chem-equilibrium/./~/process/browser.js","webpack:///chem-equilibrium/(webpack)/buildin/global.js"],"names":[],"mappings":"kDAmLA,4OCnLA,cACA,2BACA,uCACA,sCACA,cACA,GACA,iDAEA,sBACA,GAAC,mBACD,kBCTA,cAMA,MACA,eAGA,mBACA,GACA,EACA,KAIA,mDAGA,KAGA,OACA,OAIA,IAzBA,iBA4BA,MAGA,iBAA2C,OAAc,EAGzD,qBACA,OACA,8BACA,CACA,gBACA,kBAGA,GAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,OAAe,EAChD,mBACA,GACA,CAGA,mBAAsD,+CAA+D,EAGrH,MAGA,+BChEA,aAEA,MACA,QACA,UAEA,wBACA,iBACA,IACA,4BACA,gCAEA,iBACA,YACS,gCACT,cACA,wBACA,UAA2B,IAAW,EACtC,kBAGA,4BAES,iEACT,SACA,SACA,cACA,2BACA,0BAEA,+DACA,KAAuB,IAAW,MAClC,kBACA,uBAEA,qDACA,GACA,CACA,0BAEA,yEACA,eACA,EACA,IAEA,WACA,mBACA,EACA,IAEA,SACA,gBACA,EAMA,QACA,+DACA,WAAyB,SAAiB,KAC1C,cAAgC,SAAuB,QACvD,yBAGA,UACA,EAOA,aACA,yBACA,GACA,mCAEA,+DACA,cACA,EACA,IAQA,YACA,OACA,gBACA,SAEA,2BACA,8BACA,sBACA,cACA,EACA,IAOA,gBACA,4BACA,GACA,sCAEA,uDAAuB,SAAe,KACtC,qBAEA,wBACA,EACA,IAQA,eACA,CACA,0BACA,SAEA,iCACA,iCACA,aAAuB,SAAe,KACtC,yBAEA,yBACA,EACA,IACA,EAEA,WACA,oCC5IA,aAEA,QACA,UAEA,mBACA,mBACA,CACA,oBACA,YACA,eACA,CAEA,6BACA,UACA,MACA,EAEA,6BClBA,aAEA,QAQA,GACA,+BACA,uBACA,YACA,uBAEA,yBAQA,EACA,kCACA,6BACA,YACA,uBAEA,4BASA,EACA,8BACA,MACA,gBAEA,0BACA,6BAEA,+DACA,EASA,EACA,iCACA,MACA,gBAEA,0BACA,0BAEA,4DACA,IAEA,8BACA,mBACA,kBAEA,IAEA,iBACA,kBACA,OAEA,SACA,uBAGA,mDACA,uCAEA,iFACA,oCAEA,IACA,KACA,SAEA,IAEA,gCACA,6CACA,8EACA,OACA,kBACA,4BACA,mGACA,6BAEA,uCAEA,wBACA,qBACA,KAAmB,MAAgB,OACnC,WAEA,QACA,IAEA,sBACA,iCACA,KAAmB,MAAiB,KACpC,cAAuB,MAAoB,QAC3C,iCAGA,UACA,IAEA,yBACA,8BACA,WAAmB,MAAiB,KACpC,cAAuB,MAAoB,QAC3C,iCAGA,UACA,IAEA,oBACA,WACA,IAAmB,MAAiB,KACpC,cAAuB,MAAoB,QAC3C,eAGA,SACA,qBC7IA,0BA+DA,YACA,UACA,oBACA,WACA,WAEA,iBACA,QACA,wBAEA,uCAEA,uCACA,mBAGA,YACA,qBAEA,eAGA,IACA,EAUA,CAEA,oBACA,6CACA,uBAIA,2BACA,IACA,6BACA,OAGA,mFACA,GACA,qBACA,IAUA,uBACA,IACA,wCAGA,6FACA,wBAGA,IACA,4BAGA,SACA,GASA,CAkBA,cACA,IACA,wCACG,4CACH,0BAEA,wCAEA,uBACA,UACA,IACA,WAEA,IAIA,iBAKA,IAJA,qCACA,kBAEA,GAMA,CAKA,iBACA,MACA,mBACA,YACA,+BAAmB,KAAU,GAC7B,YAGA,QACA,GAIA,CAWA,oBACA,0BACA,cAGA,sBACA,wBAGA,qDACA,mBAEA,uBAEA,gBAIA,mBAGA,KACA,GAEA,iBACA,sBACA,uBACA,eAAiB,KAAY,OAC7B,SAEA,iBACA,IAEA,uBACA,OAEA,+BACA,wBAGA,wDACA,wBAGA,sDACA,2BACG,IACH,8BAEA,yBAGA,MAEA,wBACA,kBAGA,mBAEA,IACA,GAEA,iBACA,mBACA,QACA,8BAEA,IACA,eAGA,mBACA,IACA,GAEA,OACA,IACA,6EACA,4CACA,aAEA,QAGA,iCACA,qBAEA,KAEA,qBACA,sFAEA,cAGA,QACA,yBACA,2EAEA,gBACA,MAqFA,iBACA,eACA,cAEA,2CACA,6EACA,wBAEA,WACA,4BAGA,cACA,uBAGA,GAEA,OADA,gBAEA,QACA,YACA,aACA,eACA,QACA,WACA,QACA,0BACA,WACA,WACA,YACA,cACA,iBACA,UACA,kBACA,MACA,uBACA,OACA,4BACA,kBACA,cAGA,QAGA,oBACA,IASA,wBACA,WAIA,WACA,aAGA,4BACA,kBAGA,QACA,YAIA,YACA,QAEA,MACA,SAGA,eAGA,iBACA,QACA,wBAEA,QACA,WACA,0BAEA,QACA,0BAEA,QACA,aACA,2BAEA,QACA,2BAEA,QACA,WACA,YACA,cACA,6BAEA,IACA,uDACA,eACA,cAGA,OAGA,CAGA,oBACA,WACA,cACA,WACA,GAkIA,0BAEA,yBAGA,KACA,wBACA,MACG,GACH,iBACG,YACH,oBAEA,gBACA,SAEA,wBAIA,uBACA,kBACA,cACA,eACA,CAAG,SACH,cACA,cAIA,KACA,mCAIA,gBAEA,UACA,gBAEA,iBACG,OACH,+BACA,MACA,qBACA,gDACA,2CAEA,gDAGA,qBAGA,wBACA,wCAEA,2BACA,mBAmBA,OACA,UAEA,uBAEA,GAEA,QAzBA,QACA,aAEA,UACA,yBACA,2BACA,+CACA,iBACA,mBAEA,KACA,MACA,MACA,MACA,CAGA,IASA,UACA,SACA,SAAwB,MAAe,GACvC,sCACA,oBAIA,QAGA,sBANA,2BAEA,EAKA,2BACA,OAAwB,GAAQ,WAChC,QACA,UAAqB,KAAe,GACpC,iCACA,CACA,MACA,KAEA,aACA,GAGA,QACA,EAcA,wBACA,SACA,mBACA,GACA,QAGA,MACA,QAKA,QAPA,aAQA,sCAEA,4BACA,UAEA,iBAAiB,KAAY,QAC7B,kCACA,oBACA,cACA,EACA,OACA,IAEA,wBACA,qCACA,IAEA,wBACA,wBACA,IAEA,wBACA,oBACA,IAEA,wBACA,wBACA,IAEA,wBACA,qCACA,IAiFA,qBACA,wBACA,wBAEA,iCAEA,KAEA,qBACA,uBACA,WAEA,UACA,UACA,WACA,OACA,eACA,SACA,SACA,EAEA,eACA,cAEA,GAEA,GADA,GAEA,YAGA,IACA,gBACA,GACA,8BACA,MACA,YAIA,MACA,gBACA,YACA,kBACA,0CACA,0BACA,eAIA,MACA,gBACA,YACA,YACA,iCACA,sDACA,gBACA,gBAIA,YAEA,CAGA,cACA,SACK,GAEL,eACA,cACA,6BAGA,iBACA,QACA,EAEA,WACA,GAIA,CAGA,eACA,WACA,cACA,2CAIA,eACA,MACA,KACA,4BACA,MACA,uBAGA,WACA,IAEA,qBACA,QACA,yBAEA,eAAqB,MAAS,GAC9B,6BAEA,kBACA,IAEA,qBACA,QACA,yBAEA,eAAqB,MAAS,GAC9B,gCAEA,WACA,IAEA,qBACA,WAEA,wBACA,2BAEA,eACA,MAAqB,MAAS,GAC9B,eAEA,WACA,IAEA,qBACA,wBACA,OACA,MAAiB,QAAkB,WACnC,iCAEA,oBACA,IAyCA,qBACA,uCACA,uDACA,yCA8JA,8BACA,wCACA,oFACA,6EACA,sBAiDA,wBACA,oBACA,yCAAuD,MAAO,GAC9D,mCACA,OAEA,eA4BA,wBACA,yBACA,yCAAuD,MAAO,GAC9D,eAEA,wBAiJA,wBACA,yCACA,mDACA,sBAEA,2BACA,OACA,yCAEA,gDACA,MACA,EAUA,2BACA,OACA,0CAEA,iDACA,MACA,EA+HA,eAEA,yBAEA,sBAEA,QACA,oBAEA,UACA,IAEA,eACA,mBACA,+BACA,IAEA,eACA,8BACA,gBACA,IAEA,kBACA,QACA,gBACA,UACA,UACA,KAEA,SAAiB,KAAY,QAC7B,qBAGA,uBAEA,QAEA,aAEA,6BACA,KACA,QAAS,mBAET,6BACA,KACA,QAGA,IAEA,GACA,QAGA,aACA,6BACA,QACA,GACA,QAGA,4BACA,KAAK,KAEL,iCAGA,WAGA,YACA,cACA,cACA,GAAK,iBACL,cACA,SACA,KACA,UAEA,UAAK,kBACL,cACA,SACA,KACA,WACA,aAEA,UAAK,oBACL,cACA,SACA,KACA,WACA,cACA,aAEA,UACA,sBAEA,qBAEA,OACA,IAEA,eACA,QACA,UAAiB,QAAgB,OAEjC,aAEA,6BACA,IAEA,kBACA,eACA,GACA,SAAiB,QAAgB,UAGjC,WAFA,sBAGA,WACA,QACA,YACA,YAGA,UACA,IAEA,eACA,0BACA,KAEA,wBACA,YAAiB,KAAY,+BAE7B,QADA,kBAGA,UACA,IAEA,eACA,aACA,GApvDA;;;;;GAEA,SACA,SACA,aAEA,WACA,aAoTA,YACA,YACA,QAEA,YACA,KAxTA,oBAyBA,GACA,wBACA,6BAQA,UACA,IACA,uBACA,wBAAqB,6CAAmD,UACxE,GACA,eACA,gCACA,+BAAG,UACH,CACA,QACA,EAbA,KAJA,oBAKA,iBAkEA,WAEA,KACA,uBACA,uBACA,UACA,IA0BA,yBACA,qBACA,GAEA,IACA,uDACA,sBACA,8CACA,6BAEA,0CACA,OACA,KAGA,mBA8BA,0BACA,qBACA,KAgBA,0BACA,eACA,GAGA,EACA,8BACA,eACA,KAgHA,uBACA,uBACA,YAEA,yBACA,iCACA,wBAGA,8CAEA,iBACA,aAEA,2BAAuC,OAAS,GAChD,wBACA,OACA,UACA,IACA,KAGA,eACA,QACA,EACA,GAEA,yBACA,gBACA,mBACA,UACA,WACA,YACA,YACA,aACA,aACA,aACA,WACA,YACA,cACA,WACA,SACA,QAEA,YAEA,wBACA,QACA,wBAGA,kDACA,6BAGA,MACA,OACA,mBACA,KAAe,QAAiB,OAChC,gBAIA,4BACA,OACA,SAAa,QAAiB,YAC9B,WACA,mBACA,wBAEA,0DACA,WACA,MACA,OACA,KA6CA,eA0EA,yBAQA,6BACA,aACA,UACA,6BAEA,wDAAiB,KAAS,OAC1B,eAEA,SACA,OAEA,6BACA,aACA,UACA,6BAEA,wDAAiB,KAAS,OAC1B,eACA,kBAEA,SACA,OAEA,6BACA,aACA,UACA,6BAEA,wDAAiB,KAAS,OAC1B,eACA,kBACA,kBACA,kBAEA,SACA,OAEA,+BACA,QACA,2BACA,kCACA,iBACA,YAEA,+BACA,wCACA,2CACA,IACA,wBAEA,8BACA,QACA,QACA,wBACA,oDAAkD,cAClD,0BAEA,wBACA,KAEA,4CACA,gBACA,wBAGA,gCACA,iBAEA,GACA,8BAEA,GACA,iBAEA,GACA,sBAGA,0CACA,4BAGA,qCACA,SAEA,UACA,UAEA,SACA,SAGA,YACA,QACA,QACA,QAEA,kBAEA,iBACA,SACA,kBAEA,qBACA,mBAEA,OAAiB,KAAS,GAC1B,wBACA,OACA,UACA,IACA,KAGA,eACA,QACA,EACA,CAUA,EAkHA,uCACA,QACA,4BAEA,sCACA,qBACA,QAEA,0CACA,qBACA,QAiDA,uCAEA,IACA,eACA,eACA,UAEG,uBACH,uBACA,WACA,UAEG,mBACH,QACA,WACA,SACA,mBAEA,aACA,GAIA,yBACA,OAIA,8FACA,gCAEA,uCACA,4BAGA,kDAEA,QAEA,OADA,gBAEA,QACA,2BAEA,QACA,WACA,6BAEA,QACA,6BAEA,QACA,aACA,8BAEA,QAEA,8BAEA,QACA,WACA,YACA,cACA,gCAEA,IACA,uDACA,eACA,cAGA,SAEA,6BACA,OACA,MACA,yDAEA,KAsFA,YA8DA,iCACA,aACA,YACA,uBAEA,GACA,UACA,aACG,OACH,QAGA,IACA,UACA,aACG,OACH,QAGA,eAEA,OACA,SACA,wCACA,mBACG,cACH,WACA,YACA,sBAAmB,KAAc,GACjC,oBAEA,GAEA,OACA,GAIA,EAMA,yCACA,KACA,MACA,oBAEA,wBACA,OACA,KACA,gBACA,sBAGA,SACA,KAEA,yCACA,KACA,MACA,EACA,kBAGA,2BACA,SACA,aACA,wBAGA,SACA,KAEA,qCACA,yBACA,aACA,KAEA,wCACA,yBACA,6BACA,GAEA,wCACA,yBACA,4BACA,IAEA,wCACA,yBAEA,cACA,gBACA,cACA,IACA,qBAEA,wCACA,yBAEA,QACA,+BACA,eACA,UACA,KAEA,wCACA,KACA,MACA,oBAEA,wBACA,OACA,KACA,gBACA,sBAEA,cAEA,8BAEA,KACA,IAEA,wCACA,KACA,MACA,oBAEA,mBACA,MACA,aACA,iBACA,wBAEA,cAEA,8BAEA,KACA,IAEA,oCACA,yBACA,sBAEA,wBADA,KAGA,uCACA,kBACA,oCACA,gCACA,IAEA,uCACA,kBACA,oCACA,gCACA,IAEA,uCACA,yBAEA,aACA,gBACA,cACA,eACA,IAEA,uCACA,yBAEA,kBACA,eACA,eACA,UACA,IAEA,uCACA,yBACA,8BACA,IAEA,uCACA,yBACA,8BACA,IAEA,wCACA,yBACA,8BACA,IAEA,wCACA,yBACA,8BACA,IAQA,6CACA,QACA,OACA,MACA,MACA,yBACA,sBACA,EAEA,QACA,KACA,eACA,qBACA,kBAGA,oBACA,IAEA,6CACA,QACA,OACA,MACA,MACA,yBACA,sBACA,EAEA,WACA,KACA,kBACA,qBACA,kBAGA,oBACA,IAEA,yCACA,YACA,OACA,0BACA,yCACA,cACA,UACA,GAUA,4CACA,YACA,OACA,4BACA,KACA,8BACA,uBAEA,cAEA,UACA,GAEA,4CACA,YACA,OACA,4BACA,KACA,mCACA,aAEA,mBAEA,UACA,GASA,4CACA,YACA,OACA,iCACA,KACA,qCACA,mBACA,mBACA,WAEA,mBAEA,UACA,GAEA,4CACA,YACA,OACA,iCACA,KACA,mCACA,mBACA,mBACA,aAEA,mBAEA,UACA,GAEA,4CACA,QACA,OACA,MACA,wBAEA,0BACA,GAEA,QACA,KACA,KACA,eACA,qBACA,mBACA,uBAEA,eAGA,4BACA,IAEA,4CACA,QACA,OACA,MACA,wBAEA,0BACA,GAEA,WACA,KACA,KACA,kBACA,qBACA,mBACA,uBAEA,eAGA,4BACA,IAEA,wCACA,YACA,OACA,2BACA,2CACA,sBACA,YACA,UACA,GAEA,2CACA,YACA,OACA,6BACA,SACA,8BACA,uBAEA,cAEA,UACA,GAEA,2CACA,YACA,OACA,6BACA,SACA,mCACA,aAEA,mBAEA,UACA,GAEA,2CACA,YACA,OACA,kCACA,cACA,8BACA,uBACA,kBACA,mBAEA,eAEA,UACA,GAEA,2CACA,YACA,OACA,kCACA,oCACA,KACA,mCACA,mBACA,mBACA,aAEA,mBAEA,UACA,GAeA,2CACA,yBACA,KAEA,2CACA,yBACA,KAUA,4CACA,yBACA,KAEA,4CACA,yBACA,GAEA,EACA,sCACA,YACA,wBACA,8BACA,gBACA,oBAGA,kBACA,2CAGA,MACA,0BAEA,2EACA,0DAGA,oDACA,wBACA,qBAGA,OAGA,UAFA,2BAIA,aAAqB,EAAQ,MAC7B,uBAEG,uBAEH,2BAAe,KAAS,GACxB,uBAGA,kCACA,KACA,uBACA,IAIA,UACA,GAKA,EACA,sCAEA,wBACA,IACA,wBACA,MACA,UACK,QACL,yBACA,WAEA,sBACA,sBACA,GACA,YAEA,GACA,iBACA,wCAEA,mEACA,6CAEA,GAAG,KACH,0BAIA,0CACA,wBAGA,6BACA,SAGA,YACA,kCAEA,UAEA,MACA,OACA,2BAAmB,MAAS,GAC5B,cAEG,OACH,mBACA,IACA,mBACA,kBACA,cAAe,QAAiB,GAChC,uBAEA,GAEA,OACA,KAGA,EAEA,2DC7mDA,aAEA,0BACA,IACA,+BACA,QACA,4BAEA,IACA,MAIA,OAHA,4BAEA,GAMA,EACA,+BACA,iBACA,KAAmB,IAAU,EAC7B,eAEA,SACA,IAEA,kCACA,iBACA,KAAmB,IAAU,MAC7B,YACA,aAAuB,IAAa,EACpC,YAEA,CACA,OACA,qBCpCA,aAEA,cACA,gCCHA,aA2TyB,eACrB,KACK,GAAL,MAAS,EAAI,EAAO,GAAK,EACrB,MAAI,KAER,SACH,GAEmB,aAEhB,IACA,QAAY,EAAM,cAClB,KAAY,EAAM,WAClB,KAAgB,EAChB,cACH,GAEyB,eACtB,KAAK,MAAI,EAAI,EAAG,EAAI,EAAI,OAAQ,IACxB,MAAQ,EAAI,GAChB,MAAc,YAAuB,IAAV,KAAgB,KAAM,IAAI,OACrD,6BAAI,EAAO,GAAQ,KAAM,IAAI,OAC7B,6BACH,KACJ,EAEwB,aACrB,KAAK,GAAI,GAAI,EAAG,EAAI,EAAK,OACrB,OAA6B,QAAzB,QAAO,GAAK,GAAG,OACf,QADqC,QAAO,GAAK,GAAG,mBAC9C,IAAI,OAGrB,4EAE2B,aACxB,IAAI,GAAO,EACX,iBAAI,CAAC,EAAM,KAAM,IAAI,OACrB,qCAAK,MAAI,EAAI,EAAG,EAAI,EAAK,OAAQ,IACzB,MAAI,EACR,GAAI,CAAC,EAAE,YAAc,EAAE,WAAW,SAAW,EAAM,WAC/C,YAAM,IAAI,OAEd,gFACI,QADA,QAAO,GAAE,UACH,IAAI,OAEjB,iDACJ,EAEmB,eAChB,KACK,GADD,GACJ,EAAS,EAAI,EAAG,EAAI,EAAI,OACpB,IAAI,EAAG,EAAI,KAEf,UACH,E,CAhXD,GAAM,GAAS,EACf,IAAM,EAAS,EACf,IAAM,EAAgB,EAEtB,IAAM,EACF,gBACA,UACA,SAAQ,KACR,OACA,yBAGJ,OA4SA,EAAiB,QAzSX,KAmBF,CAAmB,gBACf,MAAK,QAAU,OAAc,UAAI,EACjC,KACA,QAAK,MACL,OAAK,OAAS,KAAK,cACtB,EAQD,cAEI,KAIK,GAJD,GAAO,KAAK,SAAW,OAAO,KAAK,KACvC,aAAc,EAAI,MAAM,KAAK,OAC7B,OAAmB,EAAI,MAAM,KAAK,OAAO,gBAEzC,QAAS,EAAI,EAAG,EAAI,EAAK,OAAQ,IAC7B,IAAI,GAAM,EACV,GAAI,EAAM,KAAK,OAAO,WAAW,QACjC,GAAY,CACR,CADA,QACM,KAAK,OAAO,gBAAgB,QAClC,GAAY,CAAC,CAAT,OAAY,EAAa,GAAO,KAAK,SAEzC,OAAQ,GAAO,KAAK,SAE3B,EAED,KAAK,EAAI,EAAG,EAAI,EAAQ,OACpB,IAAI,WACA,OAAQ,GAAK,EAAO,YAAY,KAAK,QAI7C,aAAK,EAAI,EAAG,EAAI,EAAa,OACzB,IAAI,WACA,OAAa,GAAK,EAAO,YAAY,KAAK,QAIlD,eACI,YACA,SAEP,EAQD,CAAc,gBAIV,IAAI,GAAU,EAAM,cACpB,OAAI,EAAQ,EAAM,WACd,OACA,EAAgB,EAAM,EAAM,cAAe,MAAQ,CAAC,GACxD,OAAI,EAFQ,EACZ,CACiB,CAAQ,EAEzB,EAAI,EAAwB,EAAM,cAAc,OAAO,MAAQ,CAAC,GAChE,OAAI,EAAqB,EAAM,cAAc,OAAO,MAAQ,GAI5D,OAAI,GAAO,GAAI,GAAO,EAAG,EAAgB,GAAO,KAEhD,SAAK,aAAa,CAAC,EAAsB,IAAI,MAAK,GAAE,OAAQ,EAC5D,GACI,KAAI,IAAY,GAAI,GAAO,CAAC,EAAmB,IAAI,MAAK,GAQ5D,WAAI,IAAS,GAAI,GAAO,EAAO,EAC/B,GAAI,GAAW,EAAO,SAAS,EAAM,WACrC,WAAO,aAAa,GAAU,EAI9B,MACA,WAAK,GAAI,EAAG,GAAI,EACZ,SAAK,GAAI,IAAI,EAAG,GAAI,EAChB,QAAO,IAAI,GAAG,GAAI,EAAO,EAAsB,IAAG,WAI1D,SAAK,GAAI,EAAG,GAAI,EAAO,KAEnB,IAAI,IAAO,EAAM,WAAW,IAC5B,iBAAI,CAEA,MAAK,KACR,QAGG,IAAI,IAAI,GAAI,GAAO,EAAG,EAAgB,GAAO,KAC7C,OAAE,IAAI,CAAC,GAAO,OACd,SAAK,SACR,GACJ,CAGD,IAAI,IAAU,GAAK,OAAO,EAAS,EAAO,EAAQ,EAClD,UAAS,GAAO,UAAU,GAC1B,OAAO,GAAgB,cAevB,IAAI,EACA,CACA,SAAI,IAAc,GAAI,GAAO,EAC7B,OAAK,GAAI,EAAG,GAAI,EACZ,SAAK,GAAI,EAAG,GAAI,EACZ,QAAY,IAAI,GAAG,GAAG,EAAmB,IAAG,WAIpD,SAAK,GAAI,EAAG,GAAI,EAEZ,QAAO,EAAM,WAAW,IACpB,cAEA,OAII,GAAI,GAAO,EAAG,GAAY,KAC9B,OAAE,IAAI,CAAC,GAAY,OACnB,SAAU,SAKlB,QAXa,KAIL,OAOE,EAAS,EAAG,EACtB,MAAc,GAAY,UAAU,GACpC,OAAY,GAAqB,cAEjC,OAAU,IAAI,CACjB,EAID,KAOK,OANL,MACA,MACA,MAGA,MACA,MAAS,GAAI,EAAG,GAAI,EACZ,QAAY,EAAM,WACtB,IAAI,GAEA,kBAAY,KAAK,GACjB,UAAO,KAAK,GAAU,cAAgB,KAAK,QAG3C,aAAO,KAAK,GAAU,MAAQ,KAAK,QACnC,WAAW,KAAK,GAChB,UAAW,KAAK,GAIxB,WAAI,IAAqB,EAAsB,IAAI,MAAK,GACxD,OAAI,GAAkB,EAAmB,IAAI,MAAK,GAClD,iBAAa,GAAW,OAAO,GAE/B,IACI,OAAO,GACP,iBAAM,GACN,mBACA,UACA,GACA,cACA,cACA,eACA,mBACA,6BAAQ,EAAQ,GAChB,gBAAY,IAAe,GAC3B,sBAAW,IAAa,GAE/B,YAQD,QACI,IAAI,GAAQ,KACZ,OAAI,EAAU,KACd,cAAI,EAAQ,EAAc,EAAM,MAAO,EAAM,KAAM,EAAM,OAAQ,EAAQ,WAAY,EAAM,WAAY,EAAM,UAAW,EAAQ,OAAQ,KACxI,SAAI,EAAS,KAAK,eAClB,SAAI,MAAK,QAAQ,aAAa,KAAK,WACnC,GACH,CASD,cACI,KACK,GADD,GAAQ,KACZ,OAAS,EAAI,EAAG,EAAI,KAAK,QAAQ,eAAgB,IAC7C,IAAI,GACA,YAAY,EAAO,YAAY,KAAK,QAAQ,OAAQ,EAAM,WAC1D,eAAQ,EAAO,YAAY,KAAK,QAAQ,OAAQ,EAAM,gBAE1D,SAAI,EAAQ,EAAc,EAAM,MAAO,EAAM,KAAM,EAAM,OAAQ,EAAQ,WAAY,EAAM,WAAY,EAAM,UAAW,EAAQ,OAAQ,KACxI,YACI,QAAO,MAAK,eAEnB,EAED,OACH,KAOD,CAAW,aACP,KAEK,MAFD,EAAU,OAAc,UAC5B,GAAI,EAAO,OAAO,KAClB,GAAS,EAAI,EAAG,EAAI,EAAK,OACjB,MAAM,EACV,GAAqB,CAAjB,KAAQ,KAAY,EAAQ,GAEpC,YAAK,SACR,CASD,CAAe,iBACX,IAAI,CAAC,EAAO,MACZ,UACK,GAAL,MAAS,EAAI,EAAG,EAAI,KAAK,OAAO,WAAW,OACvC,MAAO,KAAK,OAAO,WAAW,IAAM,EAIxC,OAAK,EAAI,EAAG,EAAI,KAAK,OAAO,OAAO,OAC/B,MAAO,KAAK,OAAO,YAAY,IAAM,KAAK,OAAO,OAGrD,SACH,EAtSa,oBChBlB,0DCAA,CAEA,gBACA,uBAEA,2CAIA,CACA,QAEA,aANA,mBACA,EAAC,8CAMD,oBACA,EAAC,aACD,aAEA,+BACA,gCAGA,4BACA,YAEA,WACA,qDAGA,SACA,EAEA,yCACA,qCACA,EAAC,YAED,CACA,QAOA,EA2BA,YACA,eACA,UA5BA,aACA,IACA,iDAGA,oCACA,GACA,EAEA,cAAiC,SAAS,EAC1C,WAQA,qBACA,QAIA,UACA,GAKA,W,sECzEA,aAgBA,gEAiiDA,eACA,oBACA,6BAEA,oCAEA,6BACA,UACA,CAMA,mCAmNA,aACA,2CAEA,UACA,EAEA,gCA9vDA,sCACA,6BACA,OACA,KASA,0BACA,MACA,MACA,4BAEA,oEACA,KAA6B,IAAe,EAC5C,cAAoC,IAAqB,EACzD,oBAGA,UACA,EAOA,oBACA,wBACA,UAA2B,MAAoB,OAC/C,gBAEA,UACA,EAOA,uBACA,6BACA,KAA2B,MAAoB,OAC/C,gBAEA,UACA,EAQA,kBACA,mBACA,EAQA,kBACA,6BACA,EAQA,iBACA,6BACA,EASA,mBACA,qBACA,+BACA,KAA2B,IAAU,EACrC,cAA+B,IAAa,EAC5C,cAGA,WACA,EAUA,wBACA,cACA,2BACA,+BACA,KAA2B,IAAU,EACrC,gBAA+B,IAAa,EAC5C,qBACA,aAGA,SACA,EASA,kBACA,gBACA,kBACA,wBACA,kBACA,KAA2B,IAAS,EACpC,cAEA,SACA,EASA,mBACA,SACA,sBACA,kBACA,0BACA,kBACA,KAA2B,IAAS,EACpC,gBAEA,UACA,EAQA,gBACA,oBACA,sBACA,eACA,SACA,qBACA,KAA2B,IAAU,EACrC,cAA+B,IAAa,EAC5C,0CAGA,WACA,EAQA,gBACA,oBACA,sBACA,eACA,SACA,qBACA,KAA2B,IAAU,EACrC,cAA+B,IAAa,EAC5C,0CAGA,WACA,EAOA,sBACA,sCACA,EAOA,mBACA,iBACA,kBAKA,WACA,uBACA,OAOA,SACA,IACA,yCAEA,8CACA,YACA,UAA2B,IAAQ,EACnC,cAA+B,IAAQ,EACvC,kBAGA,SACA,KAMA,YACA,sBACA,QAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,mCAGA,SACA,EAMA,YACA,sBACA,QAA2B,SAAe,SAC1C,iBACA,mBAA+B,SAAkB,QACjD,uBAEA,EACA,OACA,EAKA,cACA,OACA,cAKA,iBACA,OACA,iBAKA,WACA,uBACA,gBAKA,WACA,yBACA,OAKA,cACA,oBACA,WAA+B,SAAe,KAC9C,cAAmC,KAAQ,EAC3C,kCACA,GAIA,SACA,QACA,CACA,QAUA,MACA,iBACA,8BASA,MACA,iBACA,8BAYA,YACA,MACA,OACA,0EACA,KAA2B,IAAY,EACvC,cAA+B,IAAY,EAC3C,iDAGA,SACA,EAOA,QACA,WAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iBAGA,SACA,KAMA,MACA,mBACA,EAOA,UACA,yBACA,wBACA,WAA2B,SAAkB,QAC7C,oBAEA,SACA,EAOA,gBACA,+CACA,GAQA,YACA,yBACA,8BACA,aAA2B,SAAkB,QAC7C,mBAEA,UACA,KAQA,cACA,yBACA,2BACA,eAA2B,SAAkB,QAC7C,iBACA,2BACA,iBAEA,SACA,KAOA,aACA,4BACA,wBACA,QAA2B,SAAe,KAC1C,oBAEA,SACA,EAOA,mBACA,qDACA,GAQA,eACA,4BACA,iCACA,aAA2B,SAAe,KAC1C,mBAEA,UACA,KAQA,iBACA,4BACA,8BACA,eAA2B,SAAe,KAC1C,iBACA,2BACA,iBAEA,SACA,KAOA,gBACA,4BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,gBACA,4BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,gBACA,4BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,gBACA,4BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,mBACA,+BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,mBACA,+BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,mBACA,+BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAOA,mBACA,+BACA,aAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,iCAGA,UACA,KAQA,YACA,yBACA,aAA2B,SAAkB,QAC7C,+BAEA,SACA,KAQA,eACA,4BACA,aAA2B,SAAe,KAC1C,+BAEA,SACA,KAMA,MACA,sBACA,KAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBACA,iBAIA,UACA,EAMA,WACA,sBACA,GACA,UAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBACA,iBACA,QACA,OAIA,SACA,EAMA,MACA,sBACA,KAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBACA,iBAIA,UACA,EAMA,WACA,sBACA,GACA,UAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBACA,iBACA,QACA,OAIA,SACA,EAOA,UACA,yBACA,wBACA,KAA2B,SAAkB,QAC7C,kBACA,iBAGA,UACA,EAOA,eACA,yBACA,wBACA,QACA,KAA2B,SAAkB,QAC7C,kBACA,iBACA,QAGA,SACA,EAOA,UACA,yBACA,wBACA,KAA2B,SAAkB,QAC7C,kBACA,iBAGA,UACA,EAOA,eACA,yBACA,wBACA,QACA,KAA2B,SAAkB,QAC7C,kBACA,iBACA,QAGA,SACA,EAOA,aACA,4BACA,wBACA,KAA2B,SAAe,KAC1C,kBACA,iBAGA,UACA,EAOA,kBACA,4BACA,wBACA,QACA,KAA2B,SAAe,KAC1C,kBACA,iBACA,QAGA,SACA,EAOA,aACA,4BACA,wBACA,KAA2B,SAAe,KAC1C,kBACA,iBAGA,UACA,EAOA,kBACA,4BACA,wBACA,QACA,KAA2B,SAAe,KAC1C,kBACA,iBACA,QAGA,SACA,EAMA,OACA,mCACA,iBACA,KAA2B,IAAS,EACpC,oBAEA,SACA,EAQA,OACA,OAEA,QADA,gBAEA,MACA,8BAEA,kBAEA,KAMA,OACA,wBACA,IAMA,OACA,WACA,IAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBAGA,SACA,EAMA,gBACA,WACA,IAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,kBACA,gBAGA,SACA,KAOA,OACA,0BACA,wBACA,4BACA,4BAEA,+CACA,IAA2B,MAAoB,OAC/C,cAEA,SACA,EAOA,QACA,gCACA,oBAEA,mBAGA,oGACA,YACA,YAEA,iDAEA,WACA,KAA2B,IAAO,MAClC,WAA+B,IAAO,EACtC,iBAGA,eAA+B,IAAO,MACtC,OACA,IAA+B,IAAO,EACtC,uBAGA,aACA,EACA,CACA,OACA,EAEA,eACA,8CACA,sBACA,aACA,gBACA,aACA,gBACA,aACA,gBACA,aAGA,cACA,WACA,SACA,UACA,WACA,iBAUA,MALA,WADA,YAOA,IALA,WAMA,IALA,WAMA,MAJA,WARA,IAaA,CAEA,eACA,8CAEA,sBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBAEA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aACA,aAEA,eAEA,oBAEA,gBACA,QACA,mBACA,gBACA,gBACA,oBAGA,eACA,QACA,eACA,oBACA,eACA,gBACA,kBAiBA,KAVA,KANA,WAiBA,kBAnCA,iBAyBA,YAWA,2BA3BA,QAiBA,YAWA,oBAnCA,eAyBA,YAWA,UAVA,KATA,WAoBA,WAVA,KATA,WAoBA,2BA9BA,SAoBA,YAWA,WAVA,KAVA,WAqBA,WATA,KAVA,GAoBA,CAOA,gBACA,kBAaA,SACA,SACA,sBACA,QAEA,wBACA,+BACA,GAEA,CAOA,oBAQA,YACA,qBAIA,WACA,oBACA,eACiB,IACjB,kBACA,aACiB,IACjB,mBACA,aAGA,0BACA,wBAEA,2BACA,2BAEA,mCACA,mCAEA,gCACA,gCAEA,yCACA,yCAGA,4CACA,6BACA,6BACA,6BACA,6BACA,0CACA,4CAGA,oBACA,WACA,WACA,yBACA,qBACA,qBACA,WACA,WAGA,uCACA,wCACA,iCACA,8BACA,0CACA,gCACA,EACA,YA9FA,YACA,SACA,YACA,SACA,YAEA,+BAA4C,CAAG,MAAK,CAAG,QAAO,CAAG,MAAK,CAKtE,sDAkBA,gBACA,kBACA,WAGA,WA6DA,EAQA,eACA,mBACA,iBACA,KACA,uBAEA,6FACA,WAA2B,SAAe,KAC1C,uCAA+D,MAC/D,mBAEA,SACA,EAWA,kBACA,mBACA,iBACA,KACA,uBAEA,6FACA,WAA2B,SAAkB,QAC7C,yCACA,KACA,MAEA,kBAEA,SACA,EASA,oBACA,gCAEA,kBACA,YACA,YACA,SAEA,qDACA,KAA2B,IAAO,EAClC,cAA+B,IAAO,EACtC,cAAmC,IAAO,EAC1C,cAAuC,IAAO,EAC9C,0CAKA,SACA,EAMA,YACA,kEACA,QAA2B,SAAe,KAC1C,cAA+B,SAAkB,QACjD,yBAGA,UACA,EAOA,YACA,gBACA,0BAA2B,SAAe,KAC1C,sCAEA,UACA,KAOA,eACA,gBACA,0BAA2B,SAAkB,QAC7C,4CAEA,UACA,KAUA,mBACA,4BACA,4DACA,KAAkC,KAAa,EAC/C,cAAyC,KAAgB,EACzD,2BAGA,SACA,EASA,oBACA,mBACA,+BACA,2CACA,6BAGA,qFACA,KAA2B,MAAoB,OAC/C,cAAyC,KAAgB,MACzD,uBACA,uDAEA,8BACA,GAEA,OACA,EASA,uBACA,mBACA,4BACA,wCACA,0BAGA,gFACA,UAA2B,MAAoB,OAC/C,cAAsC,KAAa,MACnD,uBACA,6DAEA,6BACA,IAEA,OACA,EASA,oBACA,gCACA,kBACA,gBACA,6BACA,aAA2B,MAAiB,KAC5C,cAA+B,MAAoB,QACnD,2BAGA,SACA,KAQA,eACA,sCACA,qDACA,UAA2B,UAAwB,WACnD,SACA,eAA+B,aAA2B,OAC1D,eACA,sBAEA,EACA,OACA,EAMA,QACA,mCACA,WACA,IAA2B,IAAS,EACpC,kBAEA,SACA,EAUA,gBACA,gCACA,KAOA,WACA,gCACA,0BACA,EAOA,cACA,mCACA,6BACA,EAMA,cACA,8BACA,KAMA,iBACA,iCACA,KAUA,uBACA,qCACA,EAWA,mBACA,uCACA,EASA,MACA,oBACA,WACA,KAEA,qCACA,gBACA,gBACA,gBAEA,SACiB,sBAEjB,SACA,gBACA,kCACA,kCACA,wCACA,gBACA,gBAEA,2BACA,KAEA,kCAGA,WACA,aAEA,0DAOA,iBACA,uBACA,6CAEA,uBACA,wBACA,yBAEA,WAA2B,MAAc,OACzC,wBACA,MAOA,oDACA,mBACA,iBAGA,yBAQA,8BAgBA,4BACA,gDACA,4BACA,6CACA,oDACA,+DAMA,wBAOA;;;;;wBAWA;;;;;;;;;wBAaA;;;;;;;;;;;iBAOA;;;;;gBAWA;;;;;;;;;eAOA;;;;;wBAWA;;;;;;;;;uBAQA;;;;;gCAUA;;;;;;;;;gCAaA;;;;;;;;;;;0BAOA;;;;;yBAEA,qBAgBA,oPAEA,gCACA,0DAAoE,6BACpE,kEAA2E,iCAC3E,kEAA2E,iCAC3E,yDAAkE,cAClE,YAAmB,aAAqB,OACxC,kCACA,4CACA,6CACA,+BAEA,QAEA,IAIA,uBAIA,+NACA,yBACA,GAEA,EAhtDA,2BAitDA,0DAAoE,6BACpE,yDAAkE,YAClE,YAAmB,WAAmB,OACtC,gCACA,8BAEA,UAEA,IAIA,iFACA,UACA,aAAmB,kBAAsB,GACzC,kBAA4B,CAE5B,2BACA,yEACA,oBACA,wBACA,QAEA,2EAAsF,2BACtF,cAAuB,kBAA0B,OACjD,uCACA,6CAEA,kBAAS,KACT,aACA,oBACA,QACA,0BAEA,qEACA,iFACA,iFACA,yEACA,gBAAuB,kBAA0B,OACjD,uCACA,sDACA,sDACA,wCAEA,aACA,CAEA,OAQA,QAvxDA,8BAEA,wCACA,wCACA,mCACA,6BACA,2CACA,sCACA,sCACA,4CACA,yCACA,0CACA,kECdA,aAKA,aACA,qBACA,iBAGA,0BAEA,mBAMA,MAEA,MAPA,YACA,SACA,gBACA,KACA,QAGe,IAAU,EACzB,SAGA,cAEA,KAAe,IAAa,MAE5B,OAAmB,IAAU,EAC7B,cAGA,SAAmB,IAAU,MAC7B,SACA,gBACA,KACA,IAAuB,IAAU,EACjC,cAEA,cACA,CAEA,OACA,MAAuB,IAAU,EACjC,8BACA,QAIA,YACA,OAAuB,IAAa,EACpC,WACA,gBACA,WAGA,MACA,UACA,QAEA,KACA,CAEA,SACA,oBAA2B,IAAU,EACrC,kBAGA,EAEA,SACA,mBACA,iBACA,EAvEA,QAEA,GAuEA,YACA,sBACA,gBACA,OACA,UAAuB,IAAS,EAChC,OACA,YAGA,SACA,QACA,mBACA,YACA,SACA,2BAEA,sDACA,UAAuB,IAAS,EAChC,YAEA,SACA,EACA,6BACA,gBACA,OACA,SACA,yBACA,KAAuB,IAAU,EACjC,cAA2B,IAAa,EACxC,cACA,OACiB,OACjB,EAEA,EAIA,QACA,EACA,6BACA,gBACA,OACA,SACA,yBACA,KAAuB,IAAU,EACjC,cAA2B,IAAa,EACxC,eACA,OAEA,GAIA,QACA,EACA,8BACA,yBACA,OACA,mBACA,wBAEA,cACA,OAEA,cACA,qBAEA,qCACA,6BAGA,iCACA,8CACA,OACA,YAEA,QAAmB,IAAa,EAChC,YAA2B,IAAa,EACxC,UAA2B,IAAW,EACtC,0BAIA,WAA6B,EAAQ,SACrC,OAAuB,IAAW,EAClC,kBAEA,SAAuB,IAAO,EAC9B,UAA2B,IAAW,EACtC,0BAGA,EACA,OACA,EACA,GAEA,6BC7KA,aAQA,eACA,qBACA,mBAEA,0BAEA,KAEA,cACA,SACA,qBAEA,QACA,yCACA,2CACA,SAIA,YAFA,cACA,YAEA,OAiBA,iBAhBA,MAEA,qBACS,8FACT,KACA,gBACA,SACA,QACA,WACA,IACA,IACA,CAEA,mCAaA,8BAEA,wBAXA,YACA,WACA,YACA,YAEA,mBACA,8BAEA,4BAGyC,OAAS,QAClD,UACA,WACA,KAAuB,MAAO,EAC9B,yBAEA,kBACA,KACA,uBAEA,QAA2B,MAAO,EAClC,kBAEA,eACA,CACA,UACA,GAEA,WAAuB,KAAO,OAC9B,qBACA,QACA,KAA2B,MAAO,EAClC,yBAEA,qBACA,OAA2B,MAAO,EAClC,yBAEA,GACA,cACA,GAEA,UACA,UAAuB,MAAO,EAC9B,qBAIA,aACA,YACA,QAA2B,KAAO,EAClC,wBAEA,mBACA,KACA,yBAEA,WAA+B,KAAO,EACtC,gBAEA,cACA,CACA,eACA,uBACA,WAA+B,KAAO,EACtC,YAEA,YAA+B,KAAO,EACtC,eAAmC,KAAO,EAC1C,0BAGA,cAA+B,KAAO,EACtC,0BACA,SAAmC,KAAO,EAC1C,sBAGA,GACA,IACA,YAA+B,KAAO,EACtC,kBAGA,GACA,CAEA,oBACA,MACA,gBAEA,OACA,aAEA,QACA,qBAEA,aAEA,IACA,QAAqB,MAAQ,OAC7B,QAAuB,KAAO,EAC9B,eAEA,YACA,CACA,WAAyB,EAAQ,MACjC,kBACA,WAA+B,KAAQ,OACvC,QACA,KAA+B,MAAO,EACtC,yBAEA,qBACA,OAA+B,MAAO,EACtC,yBAEA,GACA,QAA2B,MAAO,EAClC,sBAEA,0BACA,OAA2B,QAAW,EACtC,eAEA,CAAa,KACb,QAA2B,KAAO,EAClC,eAEA,YACA,CAEA,CAEA,IACA,WAAuB,EAAQ,WAC/B,WACA,qBAA+B,KAAO,OACtC,QACA,QAAmC,KAAO,EAC1C,yBAEA,uBACA,UAAmC,KAAO,EAC1C,yBAEA,GAEA,QAAuB,KAAO,EAC9B,eAEA,YACA,CAGA,eACA,KACA,EACA,+BACA,WAAuB,GAAS,QAIhC,OAHA,iEAIA,QACA,EACA,KAEA,YACA,KACS,MACT,WAA4B,MAAS,SAIrC,GAHA,mDAIA,6CACA,OACA,EACA,KAEA,MACA,MACa,UACb,KAEA,MACA,KAEA,GAEA,QAEA,KACA,WACA,cACA,YACA,QAA+B,MAAQ,GACvC,mBACA,aACA,SACA,SACA,QACA,kBACA,qBAEA,IACA,SAAmC,KAAO,EAC1C,iCACA,yCACA,aAIA,GACA,KACA,QACA,cACA,YACA,KAA2B,MAAO,GAClC,mBACA,aACA,SACA,SACA,aACA,iBACA,IACA,SAAmC,KAAO,EAC1C,iCACA,yCACA,aAIA,GACA,KACA,QACA,kIACA,iBACA,cACA,eACA,YACA,aACA,8BACA,eACA,OACA,WACA,6BACA,IACA,WAEA,cAEA,wBACA,SACA,MAA2B,SAAW,OACtC,YACA,UACA,SACA,QACA,cAEA,sBACA,0BACA,eACA,mBACA,GACA,SAAmC,KAAO,EAC1C,iCACA,yCACA,aAGA,cACA,UACA,SACA,SACA,wBACA,8BACA,eACA,qBACA,WACA,SAAmC,KAAO,EAC1C,iCACA,yCACA,aAGA,EACA,UAEA,QACA,KACA,QACA,IACA,gCACA,EACA,UAAmC,MAAS,GAC5C,sBAIA,YACA,kBAGA,cACA,eACA,WACA,WACA,SAAmC,KAAO,EAC1C,iBACA,qBACA,cAGA,cACA,SAAmC,KAAO,EAC1C,iBACA,qBACA,cAGA,GAEA,QACA,EACA,KACA,KAGA,EAEA,MACA,QACA,IACA,IACA,EAEA,QACA,SACA,SACA,SACA,SACA,EArYA,QACA,OACA,OACA,eAEA,iBAkYA,YACA,gBACA,iDACA,EACA,aACA,eACA,EACA,YAEA,0CACA,2BACA,SACA,UAAsC,SAAQ,EAC9C,SACA,GAGA,UACA,EACA,gBACA,aACA,CAEA,iBACA,+DACA,EACA,2BACA,+BACA,8BAEA,SACA,CACA,4BACA,+BACA,8BAEA,SACA,CACA,sBACA,2BACA,EACA,mBAEA,IAMA,UAJA,mBACA,0BACA,SAEmB,IAAW,EAC9B,iCACA,EAEA,WAIA,cACA,SAEA,8BACA,OACA,SACA,0BACA,OAEA,SAAmB,IAAW,EAC9B,UAAuB,IAAW,MAClC,QACA,IAA2B,IAAW,EACtC,qBAEA,WACA,EAGA,UACA,KAjCA,EAkCA,8BACA,iCACA,GACA,oBACA,YACA,SACA,cACA,cACA,+BACA,UAEA,QAAmB,IAAW,EAC9B,UAAuB,IAAW,EAClC,gCACA,iBAEA,GAKA,aAEA,MACA,cACA,wBACA,KAEA,QAAmB,IAAW,EAC9B,UAAuB,IAAW,MAClC,OACA,IAA2B,IAAW,EACtC,oBAEA,WACA,CAGA,OACA,EACA,GAEA,6BCjgBA,aAEA,sBACA,2DCHA,aAEA,eACA,UACA,CAMA,CACA,iBACA,WACA,IAAmB,MAAmB,OACtC,SAEA,SACA,EAMA,EACA,iBACA,aACA,OACA,SAAmB,IAAO,EAC1B,iBAEA,UACA,EAMA,EACA,iBACA,aACA,OACA,SAAmB,IAAO,EAC1B,iBAEA,UACA,EAMA,EACA,oBACA,aACA,OACA,OACA,SAAmB,IAAO,EAC1B,iBACA,iBAEA,UACA,KACA,MAEA,EAMA,EACA,4BACA,WACA,MACA,SAAmB,IAAO,EAC1B,SAEA,YACA,CAIA,EACA,SAMA,eACA,2BACA,WACA,MACA,SAAmB,IAAO,EAC1B,SAEA,uBACA,EAQA,EACA,qBACA,WACA,MACA,SAAmB,IAAO,EAC1B,kBAEA,aACA,CAOA,EACA,yBACA,WACA,IACA,MACA,SAAmB,IAAO,EAC1B,cACA,QAEA,YACA,CAQA,EACA,+BACA,cACA,MACA,wBAEA,gBACA,sBACA,KACA,IAAmB,MAAa,EAChC,SAEA,iBACA,EAMA,EACA,0BACA,WACA,MACA,SAAmB,IAAO,MAC1B,IACA,kDAEA,kBACA,EACA,UACA,CAMA,EACA,gCACA,WACA,IACA,MACA,SAAmB,IAAO,EAC1B,cACA,QAEA,MACA,yBAEA,sCACA,CAOA,EACA,sBACA,cACA,MACA,wBAEA,YACA,sBACA,SACA,QAEA,oBAEA,EAOA,EACA,wBACA,cACA,yBACA,KACA,MAEA,SAAmB,IAAO,EAC1B,WACA,OAGA,QACA,QAEA,KAEA,CAOA,EACA,iCACA,+BACA,KAEA,2BACA,2CACA,OAOA,EACA,gCACA,WACA,eACA,QAAe,IAAY,EAC3B,SAEA,MACA,cACA,SAAe,IAAY,EAC3B,uBACA,iBACA,KACA,kBAEA,6BAGA,OACA,MACA,QAEA,IAEA,yBACA,yBACA,MACA,wBAGA,mBACA,mBACA,cACA,yBAEA,UAAY,aACZ,IAEA,uCACA,qCACA,KAEA,8BACA,yBACA,gBACA,UACA,SA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CACA,oBACA,SAAwB,WACxB,wBAIA,uBACA,OACA,MAAwB,WACxB,cAKA,WACA,mCACA,OACA,MAAwB,WACxB,cAIA,QACA,oBhC5LA,aAqDA,qBACA,wBA8BA,mBACA,GAEA,SA/BA,kBACA,KAGA,IADA,UAGA,YACA,8BAGA,KACA,MAEA,YACA,aACA,UACA,KAEA,KACA,KACA,KACA,KACA,KAEA,KACA,KAEA,cAKA,eAEA,oBACA,aAEA,iBACA,EAEA,UACA,OAEA,QACA,KACA,KACA,EAEA,WACA,oBACA,UAGA,mBAEA,OACA,MAEA,MACA,QACA,SACA,IACS,WACT,QACA,KAGA,iBACA,cACA,EAEA,OACA,EAWA,CACA,qBACA,SAEA,kBACA,8BAGA,KACA,IAHA,UAMA,KACA,MAEA,wBAEA,OACA,QACA,MACA,EAEA,SAGA,KAEA,KACA,KAEA,cACA,0BACA,6CAEA,IACA,KACA,KAGA,wBACA,GAEA,UACA,OAEA,QACA,KACA,KACA,KACA,CAEA,GACA,QACA,EAGA,6BACA,OAEA,OACA,KAEA,MACA,QACA,SACA,IAEA,WACA,KACA,EAEA,KAEA,OACA,EAUA,CACA,mBACA,mCACA,GAEA,uBAnOA,eACA,oBACA,iBACA,sBAGA,mBACA,gBACA,4BAEA,gEAEA,mCACA,4BACA,wBAEA,uEACA,0BACA,wBAGA,yCACA,OACA,OACA,IACA,IACA,CAEA,uCACA,sCACA,wBAEA,kDACA,yBAEA,6EAEA,4CAEA,wBACA,CAWA,EAiLA,W,mBiC7PA,kBAGA,kDACA,iCCJA,aAEA,MASA,WACA,kBACA,yBACA,OACA,UAAmB,MAAiB,OACpC,kBAEA,QACA,IAhBA,WAOA,uBCVA,aAKA,aACA,qBACA,iBAEA,sBACA,MACA,8BAGA,mCAMA,IALA,MACA,eACA,GACA,WAEe,IAAe,MAC9B,SACA,KACA,QAAmB,IAAO,MAC1B,SACA,KACA,QAAuB,IAAO,EAC9B,cAEA,2BACA,QACA,CAEA,eAEA,KACA,iCACA,QAAuB,IAAe,EACtC,YAEA,CAEA,KACA,kBAGA,0CACA,EA7CA,WAEA,OA6CA,YACA,4BACA,aACA,CACA,mBACA,iBAEA,cACA,MAEA,iBACA,kBAGA,0CAIA,MAHA,YACA,cAEmB,IAAe,EAClC,UAAuB,IAAW,MAClC,OAA2B,IAAO,EAClC,0BAEA,iBACA,EAGA,SAA+B,EAAQ,KACvC,UAAuB,IAAW,MAClC,SAA+B,IAAe,EAC9C,0BAEA,iBACA,EAGA,OACA,EACA,GAEA,6BCzFA,aAYA,eACA,aAA8B,YAC9B,oBACA,mBAEA,sBACA,MACA,2BAGA,uCAOA,OANA,gBACA,WACA,WACA,KACA,EAGA,gBAGA,mBAGA,iBACA,OAAmB,IAAO,EAC1B,WAAuB,KAAO,EAC9B,sBAGA,YACA,WACA,EAAK,KACL,cACA,YACA,UAAmB,KAAO,EAC1B,WAAuB,IAAO,EAC9B,sBAGA,cACA,aACA,GAEA,QACA,SACA,SACA,SACA,EAoCA,mBAEA,gBACA,MAEA,UAAe,KAAO,EACtB,kBAGA,YAAmB,EAAO,QAC1B,QACA,IACA,KAAmB,KAAO,EAC1B,oBAGA,QACA,oBACA,MAAuB,KAAO,EAC9B,kBACA,aACA,WAES,MACT,QAAuB,KAAO,EAC9B,YACA,cAGA,cACA,eACA,GACA,SAGA,WACA,OACA,WACA,KAAuB,KAAO,EAC9B,WAGA,SAAuB,KAAO,OAC9B,SACA,aACA,oBACA,QAA+B,QAAY,EAC3C,oBACA,qBAEA,QACA,CAEA,OACA,KAAuB,KAAO,EAC9B,YACA,aAGA,gBACA,MAAuB,KAAO,EAC9B,iBAGA,WAAuB,KAAO,OAC9B,SACA,QACA,OAA2B,SAAY,EACvC,4BAEA,iBACA,aACA,CACA,CACA,MACA,CAEA,OAAe,MAAW,MAC1B,mBACA,WACA,QACA,SACA,QAAuB,MAAQ,EAC/B,sBAGA,SAAuB,MAAQ,OAC/B,OACA,KAA2B,MAAQ,EACnC,yBAEA,WAA2B,MAAQ,EACnC,oBAEA,GACA,CAEA,QAAmB,MAAQ,EAC3B,gBAEA,CAEA,QAAe,KAAO,EACtB,kBACA,eAGA,cACA,OACA,EAEA,mBAEA,yBACA,qBACA,GAEA,SAAe,IAAO,EACtB,aAGA,UAEA,SACA,KACA,EAEA,gCAAe,KAAO,OACtB,+CACA,SACA,MACA,yBAGA,KAGA,cACA,IACA,IAGA,cACA,wBACA,aACA,GACA,WAGA,oBACA,sBACA,YACA,SACA,SAA+B,IAAO,EACtC,UAGA,UAEA,OACA,OACA,KACA,MACA,WACA,MACA,KACA,OAA+B,KAAQ,GACvC,WACA,MACA,MACA,UACA,QACA,aACA,cACA,WACA,SACA,iBACA,yBAEA,OAA+B,KAAO,EACtC,eACA,6BACA,0BAIA,wBACA,YACA,YAEA,EACA,0BACA,GACA,QACA,SACA,CAEA,OAAe,MAAW,MAC1B,QACA,OACA,OAAuB,IAAO,EAC9B,SACA,QACA,OAIA,YACA,cACA,QACA,KAAuB,IAAO,EAC9B,YACA,gBACA,aAGA,EACA,EAEA,mBAEA,kBAGA,GAEA,KAJA,MACA,WAGqB,QAAe,OACpC,QACA,KAAmB,OAAW,EAC9B,2BAGA,cACA,QACA,KAA0B,MAAQ,GAClC,uBACA,eAGA,oBACA,IACA,aAGA,aACA,SAEA,KAAuB,MAAO,OAC9B,OACA,KAA8B,MAAQ,GACtC,oBAGA,WACA,MAA2B,OAAW,EACtC,oBAEA,GAEA,QAAuB,MAAW,OAClC,OACA,KAA8B,MAAQ,GACtC,oBAGA,WACA,MAA2B,OAAW,EACtC,oBAEA,GAEA,YACA,mBACA,CACA,CAEA,QAAe,KAAO,EACtB,YAAmB,KAAO,EAC1B,yBAIA,WAAsB,QAAc,EACpC,wBACA,WAA2B,MAAW,EACtC,oBAGA,UAAuB,OAAW,OAClC,OACA,KAA2B,OAAW,EACtC,oBAGA,2BACA,MAA2B,OAAW,EACtC,oBAEA,GACA,CAEA,EAEA,qBACA,6BAaA,YACA,MAEA,OAfA,IACA,MACA,EACA,4BACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,SAIe,KAAQ,EACvB,mBACA,iBACA,UAGA,oBAAoC,MAAQ,EAC5C,wBAIA,gBACA,QACA,KACA,8CACA,KACA,YAEA,+BAGA,MAGA,aACA,WACA,aACA,QACA,EACA,OACS,mBACT,wBACA,4BACA,WACA,yBACA,cACA,2BACA,WAEA,SACA,uBACA,aACA,YACA,GACA,oBAEA,WACA,OACA,YACA,4BACA,UACA,SACA,yBACA,QACA,OAEA,QAA+B,KAAQ,EACvC,eACA,6BACA,4BAGA,UAA2B,MAAQ,EACnC,gBACA,6BACA,2BAGA,UAA6B,MAAW,EACxC,gBACA,6BACA,2BAEA,EACA,gBACA,WACA,UACA,SAGA,MACA,KACA,CAAS,KACT,YACA,MACA,KACA,KACA,gBACA,uBAGA,WACA,SACA,MAA6B,MAAQ,EACrC,gBAEA,4CACA,eACA,iBACA,EAEA,IACA,oBACA,WACA,SACA,kBACA,OACA,SAEA,wBACA,OAAiC,MAAQ,EACzC,gBAEA,OACA,YACA,KAKA,eACA,MACA,cACA,UACA,SACA,sCACA,0BACA,iBACA,yCACA,QACA,OACA,OACA,QAGA,oIAGA,QAGA,eAA2B,MAAQ,EACnC,iBACA,QACA,gBAIA,UAAuB,SAAY,cAEnC,OACA,iBACA,iBACA,uBACA,wCACA,IACA,aACA,OACA,OAIA,KAIA,QAjBA,oCAkBA,IACA,WAGA,WACA,UACA,QAEA,2BAGA,oBAJqB,OAKrB,SACA,SACA,SACA,OACA,OAEA,MAA+B,MAAQ,EACvC,6BACA,IACA,oBACA,+BAGA,kBACA,8BAGA,UAA+B,oBAAyB,GACxD,iCACA,GACA,qBACA,8BAGA,eACA,8BAGA,UAAiC,MAAW,EAC5C,iCACA,GACA,qBACA,8BAGA,eACA,8BAEA,EAEA,CACA,CAEA,IAIA,gBAAoB,EAAQ,KAC5B,YACA,QAEA,GACA,cACA,UACA,OAA2B,EAAQ,WACnC,kBACA,MACA,KAA2B,OAAQ,EACnC,yBAGA,MACA,WACA,MAEA,cACA,GACA,kCAEA,wBACA,cACA,qCACA,qBACA,YACA,mEAGA,sBACA,IACA,kBAAmC,OAAQ,EAC3C,eAIA,EACS,SACT,cAEA,sCACA,2BACA,kCAEA,sCACA,mBACA,gBAGA,cACA,UACA,OAA2B,EAAQ,WACnC,QACA,KACA,KAA2B,OAAQ,EACnC,2BACA,uBAGA,mBAEA,GACA,WACA,MACA,MAEA,cACA,GACA,2BACA,kBACA,eAEA,iBACA,cACA,4CACA,mBACA,WACA,gFAEA,kDACA,kBACA,eACA,sCACA,kDACA,8CAEA,+CACA,oBACA,iBAIA,qDACA,KACA,kBAAmC,OAAQ,EAC3C,2BACA,aAIA,EAIA,QAAe,KAAQ,EACvB,iBACA,SAAuB,MAAQ,EAC/B,qBAKA,aAAoB,MAAU,EAC9B,YAAqB,MAAW,OAChC,QACA,KAAyB,kBAAwB,GACjD,yBAEA,cACA,EAEA,GAEA,mBACA,OACA,8BACA,QACA,QACA,qBAEA,SACA,QACA,qBAEA,IAvwBA,aACA,WACA,OACA,eAEA,mBACA,CAGA,oBAmDA,YACA,sBACA,aACA,CACA,4BACA,aACA,CACA,yBACA,wBACA,uBAEA,SACA,CACA,sBACA,OAKA,SAJA,SACA,SACA,YACA,SACmB,IAAO,MAC1B,OAAuB,IAAO,EAC9B,YAEA,YACA,GACA,mBACa,GACb,qBAEA,GACA,OACA,EACA,GA6qBA,6BC3wBA,aAMA,aACA,qBACA,iBAEA,mBAEA,aAMA,MALA,YACA,SACA,gBACA,SAEe,IAAO,MACtB,OACA,QAAmB,IAAO,EAC1B,eAEA,aACA,KACA,eAEA,KAAuB,IAAO,EAC9B,aAEA,eACA,MAA2B,IAAO,MAClC,OACA,IAA2B,IAAO,EAClC,oBAEA,iBACA,KAA2B,IAAO,EAClC,oBAEA,EACA,CACA,OACA,CAEA,SACA,aACA,EA7CA,WACA,cAEA,WA4CA,YACA,kBACA,iBAEA,cACA,OAEA,iBACA,kBAEA,6CACA,6BAGA,oCACA,YACA,YACA,cAEA,QAAmB,IAAO,EAC1B,UAAuB,IAAW,MAClC,OACA,IAA2B,IAAO,EAClC,oBAEA,iBACA,KAA2B,IAAO,EAClC,oBAEA,EAEA,SAAuB,EAAQ,SAC/B,OAAuB,IAAW,EAClC,wBAEA,SAAuB,IAAO,EAC9B,UAA2B,IAAW,EACtC,0BAGA,EAEA,8BACA,EACA,uBACA,mBACA,UAAuB,IAAa,EACpC,OACA,kBAGA,SACA,QACA,6BACA,OAIA,SAHA,OACA,kBACA,SACmB,IAAO,EAC1B,UAAuB,IAAO,EAC9B,cACA,OACiB,OACjB,aAEA,GAIA,QACA,EACA,wBACA,WAMA,SALA,OACA,SACA,kBACA,WAE6B,EAAQ,SACrC,OAAuB,IAAU,EACjC,YAEA,cACA,IAAuB,IAAa,EACpC,mBACA,OACA,IAA+B,IAAU,EACzC,oBAGA,iBAEA,KAA+B,IAAU,EACzC,oBAEA,EAEA,CACA,OACA,EACA,GAEA,6BCvJA,aAUA,aACA,wBACA,eACA,MASA,CAeA,eACA,wBACA,mBACA,iDACA,GAvCA,WAEA,WACA,QACA,QACA,QACA,YAeA,gBASA,EACA,8CACA,UACA,OAQA,UACA,6BACA,eACA,IAEA,UACA,4BACA,MACA,0BACA,MACA,kBACA,KACA,kBACA,KACA,wBACA,MACA,UACA,QACA,eC3DA,oBACA,oCACA,+BCJA,aAEA,WAkBA,UAhBA,eACA,iBACA,gBACA,eACA,CAEA,WACA,sCACA,GACA,IAEA,OACA,+BACA,OACA,oBClBA,aAEA,WAiBA,UAfA,eACA,eACA,kBACA,QAEA,WACA,2CACA,GACA,IAEA,SACA,yCACA,EACA,oBCjBA,aAEA,WAiBA,UAfA,eACA,eACA,kBACA,QAEA,WACA,wCACA,GACA,IAEA,SACA,sCACA,EACA,oBCjBA,aAEA,WAkBA,UAhBA,eACA,iBACA,aACA,kBACA,CAEA,WACA,mCACA,GACA,IAEA,SACA,iCACA,EACA,oBClBA,aAEA,QACA,UAoBA,UAlBA,eACA,mBACA,0BACA,iCACA,0BACA,yBACA,MAEA,WACA,iEACA,GACA,IAEA,SACA,8DACA,GACA,oBCrBA,aAEA,QACA,UAoBA,UAlBA,eACA,uBACA,sBACA,qBACA,iBACA,mBACA,CAEA,WACA,2DACA,GACA,IAEA,SACA,yDACA,EACA,oBCrBA,aAEA,WAiBA,UAfA,eACA,eACA,qBACA,KAEA,WACA,4BACA,GACA,IAEA,SACA,0BACA,EACA,oBCjBA,aAIA,eACA,UACA,EAJA,YAMA,iBACA,YACA,WAAmB,MAAmB,OACtC,cAAuB,SAAsB,OAC7C,uBAGA,UACA,IAEA,iBACA,WACA,WAAmB,MAAmB,OACtC,cAAuB,SAAsB,OAC7C,uBAGA,UACA,IAEA,oB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OACA,eAA0C,SAAQ,EAClD,sBACA,kBAGA,GACA,OACA,IAEA,gCACA,cACA,OACA,gBACA,wBACA,eAEA,KAAmB,IAAU,MAC7B,WACA,QAEA,IAAuB,IAAU,MACjC,iBACA,OAEA,WACA,MACA,OACA,CAEA,gBACA,GAEA,OACA,IAEA,8BACA,CACA,0BAEA,WACA,gBACA,uBAGA,SAFA,gBAGA,aACA,KAAmB,IAAU,EAC7B,SAEA,QAAmB,IAAU,EAC7B,YACA,OACA,KAAuB,IAAU,EACjC,eAGA,CAAK,eACL,aACA,KAAmB,IAAU,EAC7B,SAEA,QAAmB,IAAU,EAC7B,YACA,OACA,KAAuB,IAAU,EACjC,eAGA,CACA,sBAGA,iCACA,MACA,kBAAsC,SAAQ,EAC9C,UAGA,QACA,IAEA,sCACA,MACA,0BACA,iBACA,UAAwC,SAAQ,EAChD,SACA,aAEA,gBACA,oCACA,IAEA,qCACA,MACA,0BACA,GACA,0BAEA,WACA,UACA,MAEA,uBAGA,SAFA,gBAGA,aACA,KAAmB,IAAU,EAC7B,eAEA,SAAmB,IAAU,EAC7B,UAAuB,IAAU,MACjC,OACA,IAA2B,IAAU,EACrC,sCAEA,cACA,YACA,CAEA,CAAK,eACL,aACA,KAAmB,IAAU,EAC7B,eAEA,SAAmB,IAAU,EAC7B,UAAuB,IAAU,MACjC,OACA,IAA2B,IAAU,EACrC,sCAEA,cACA,YACA,CAEA,CACA,sBAGA,2BACA,gBChmBA,CA2CA,aAEA,kBAGA,4IACA,MAGA,sBACA,mBACA,oBAEA,UADA,GAEA,YACA,WACA,UACA,UACA,EACA,YACA,WACA,UACA,EACA,aACA,YACA,WACA,UACA,UACA,EACA,eACA,cACA,YACA,WACA,UACA,EACA,eACA,cACA,YACA,WACA,UACA,EACA,oBACA,mBACA,aACA,YACA,SAIA,UAQA,CAEA,aACA,WACA,kBAEA,OACA,kBAEA,OACA,kBAEA,OACA,kBAEA,MACA,IAQA,CAEA,aACA,cACA,cACA,eACA,iBACA,aACA,KAIA,CAEA,iBACA,UAGA,WACA,0BAEA,uBACA,IAhJA,GACA,SACA,OACA,OACA,OAcA,SAEA,uBACA,GACA,kBACA,mBACA,oBACG,8BACH,YACA,OACA,KAEA,0FACA,GAQA,cC3CA,CAWA,YACA,iBACA,mCACA,YACA,iBACA,oCACA,CAoBA,aACA,QAEA,+BAGA,mBACA,oBACA,wBAEA,MAEA,YACA,EAAK,SACL,IAEA,sBACA,EAAS,SAET,sBACA,EACA,CAGA,EACA,aACA,QAEA,iCAGA,mBACA,sBACA,0BAEA,MAEA,UACA,EAAK,SACL,IAEA,oBACA,EAAS,SAGT,oBACA,EACA,CAIA,EAMA,YACA,IAGA,IACA,OACA,kBAEA,MAEA,IACA,QAEA,KAEA,YACA,KAGA,WACA,GAEA,iBACA,UACA,OACA,EACA,SACA,GACA,QAGA,SACA,MACA,MACA,GACA,KACA,OACA,IAgBA,eACA,UACA,aACA,EAWA,cAhKA,QAOA,WACA,eASA,IACA,GACA,8BAEA,WAEA,CAAK,SACL,GACA,CACA,IACA,GACA,gCAEA,aAEA,CAAK,SACL,GACA,CACA,CAAC,KAqDD,GACA,MACA,KACA,OAyCA,sBACA,8BACA,MACA,6BAAuB,cAAsB,OAC7C,qBAGA,kBACA,kBACA,KAEA,EAEA,EAKA,0BACA,0BACA,QACA,kBACA,aACA,SACA,UACA,UAAqB,GACrB,cAIA,OACA,gBACA,SACA,QACA,mBACA,uBACA,SAEA,oBACA,iBACA,qCAEA,gBAA2B,YAC3B,kBACA,iBACA,mCACA,kBAA4B,OAAU,iBCnLtC,GAGA,aACA,OACA,KAAC,IAED,GAEA,0CACA,OAAC,SAED,CACA,4BACA,OAI4C,CAE5C","file":"chem-equilibrium.min.js","sourcesContent":["'use strict';\n\n/**\n *\n * Function that returns a Number array of equally spaced numberOfPoints\n * containing a representation of intensities of the spectra arguments x\n * and y.\n *\n * The options parameter contains an object in the following form:\n * from: starting point\n * to: last point\n * numberOfPoints: number of points between from and to\n * variant: \"slot\" or \"smooth\" - smooth is the default option\n *\n * The slot variant consist that each point in the new array is calculated\n * averaging the existing points between the slot that belongs to the current\n * value. The smooth variant is the same but takes the integral of the range\n * of the slot and divide by the step size between two points in the new array.\n *\n * @param x - sorted increasing x values\n * @param y\n * @param options\n * @returns {Array} new array with the equally spaced data.\n *\n */\nfunction getEquallySpacedData(x, y, options) {\n    if (x.length>1 && x[0]>x[1]) {\n        x=x.slice().reverse();\n        y=y.slice().reverse();\n    }\n\n    var xLength = x.length;\n    if(xLength !== y.length)\n        throw new RangeError(\"the x and y vector doesn't have the same size.\");\n\n    if (options === undefined) options = {};\n\n    var from = options.from === undefined ? x[0] : options.from\n    if (isNaN(from) || !isFinite(from)) {\n        throw new RangeError(\"'From' value must be a number\");\n    }\n    var to = options.to === undefined ? x[x.length - 1] : options.to;\n    if (isNaN(to) || !isFinite(to)) {\n        throw new RangeError(\"'To' value must be a number\");\n    }\n\n    var reverse = from > to;\n    if(reverse) {\n        var temp = from;\n        from = to;\n        to = temp;\n    }\n\n    var numberOfPoints = options.numberOfPoints === undefined ? 100 : options.numberOfPoints;\n    if (isNaN(numberOfPoints) || !isFinite(numberOfPoints)) {\n        throw new RangeError(\"'Number of points' value must be a number\");\n    }\n    if(numberOfPoints < 1)\n        throw new RangeError(\"the number of point must be higher than 1\");\n\n    var algorithm = options.variant === \"slot\" ? \"slot\" : \"smooth\"; // default value: smooth\n\n    var output = algorithm === \"slot\" ? getEquallySpacedSlot(x, y, from, to, numberOfPoints) : getEquallySpacedSmooth(x, y, from, to, numberOfPoints);\n\n    return reverse ? output.reverse() : output;\n}\n\n/**\n * function that retrieves the getEquallySpacedData with the variant \"smooth\"\n *\n * @param x\n * @param y\n * @param from - Initial point\n * @param to - Final point\n * @param numberOfPoints\n * @returns {Array} - Array of y's equally spaced with the variant \"smooth\"\n */\nfunction getEquallySpacedSmooth(x, y, from, to, numberOfPoints) {\n    var xLength = x.length;\n\n    var step = (to - from) / (numberOfPoints - 1);\n    var halfStep = step / 2;\n\n    var start = from - halfStep;\n    var output = new Array(numberOfPoints);\n\n    var initialOriginalStep = x[1] - x[0];\n    var lastOriginalStep = x[x.length - 1] - x[x.length - 2];\n\n    // Init main variables\n    var min = start;\n    var max = start + step;\n\n    var previousX = Number.MIN_VALUE;\n    var previousY = 0;\n    var nextX = x[0] - initialOriginalStep;\n    var nextY = 0;\n\n    var currentValue = 0;\n    var slope = 0;\n    var intercept = 0;\n    var sumAtMin = 0;\n    var sumAtMax = 0;\n\n    var i = 0; // index of input\n    var j = 0; // index of output\n\n    function getSlope(x0, y0, x1, y1) {\n        return (y1 - y0) / (x1 - x0);\n    }\n\n    main: while(true) {\n        while (nextX - max >= 0) {\n            // no overlap with original point, just consume current value\n            var add = integral(0, max - previousX, slope, previousY);\n            sumAtMax = currentValue + add;\n\n            output[j] = (sumAtMax - sumAtMin) / step;\n            j++;\n\n            if (j === numberOfPoints)\n                break main;\n\n            min = max;\n            max += step;\n            sumAtMin = sumAtMax;\n        }\n\n        if(previousX <= min && min <= nextX) {\n            add = integral(0, min - previousX, slope, previousY);\n            sumAtMin = currentValue + add;\n        }\n\n        currentValue += integral(previousX, nextX, slope, intercept);\n\n        previousX = nextX;\n        previousY = nextY;\n\n        if (i < xLength) {\n            nextX = x[i];\n            nextY = y[i];\n            i++;\n        } else if (i === xLength) {\n            nextX += lastOriginalStep;\n            nextY = 0;\n        }\n        // updating parameters\n        slope = getSlope(previousX, previousY, nextX, nextY);\n        intercept = -slope*previousX + previousY;\n    }\n\n    return output;\n}\n\n/**\n * function that retrieves the getEquallySpacedData with the variant \"slot\"\n *\n * @param x\n * @param y\n * @param from - Initial point\n * @param to - Final point\n * @param numberOfPoints\n * @returns {Array} - Array of y's equally spaced with the variant \"slot\"\n */\nfunction getEquallySpacedSlot(x, y, from, to, numberOfPoints) {\n    var xLength = x.length;\n\n    var step = (to - from) / (numberOfPoints - 1);\n    var halfStep = step / 2;\n    var lastStep = x[x.length - 1] - x[x.length - 2];\n\n    var start = from - halfStep;\n    var output = new Array(numberOfPoints);\n\n    // Init main variables\n    var min = start;\n    var max = start + step;\n\n    var previousX = -Number.MAX_VALUE;\n    var previousY = 0;\n    var nextX = x[0];\n    var nextY = y[0];\n    var frontOutsideSpectra = 0;\n    var backOutsideSpectra = true;\n\n    var currentValue = 0;\n\n    // for slot algorithm\n    var currentPoints = 0;\n\n    var i = 1; // index of input\n    var j = 0; // index of output\n\n    main: while(true) {\n        if (previousX>=nextX) throw (new Error('x must be an increasing serie'));\n        while (previousX - max > 0) {\n            // no overlap with original point, just consume current value\n            if(backOutsideSpectra) {\n                currentPoints++;\n                backOutsideSpectra = false;\n            }\n\n            output[j] = currentPoints <= 0 ? 0 : currentValue / currentPoints;\n            j++;\n\n            if (j === numberOfPoints)\n                break main;\n\n            min = max;\n            max += step;\n            currentValue = 0;\n            currentPoints = 0;\n        }\n\n        if(previousX > min) {\n            currentValue += previousY;\n            currentPoints++;\n        }\n\n        if(previousX === -Number.MAX_VALUE || frontOutsideSpectra > 1)\n            currentPoints--;\n\n        previousX = nextX;\n        previousY = nextY;\n\n        if (i < xLength) {\n            nextX = x[i];\n            nextY = y[i];\n            i++;\n        } else {\n            nextX += lastStep;\n            nextY = 0;\n            frontOutsideSpectra++;\n        }\n    }\n\n    return output;\n}\n/**\n * Function that calculates the integral of the line between two\n * x-coordinates, given the slope and intercept of the line.\n *\n * @param x0\n * @param x1\n * @param slope\n * @param intercept\n * @returns {number} integral value.\n */\nfunction integral(x0, x1, slope, intercept) {\n    return (0.5 * slope * x1 * x1 + intercept * x1) - (0.5 * slope * x0 * x0 + intercept * x0);\n}\n\nexports.getEquallySpacedData = getEquallySpacedData;\nexports.integral = integral;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-array-utils/src/getEquallySpaced.js\n// module id = 30\n// module chunks = 0","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"chemEquilibrium\"] = factory();\n\telse\n\t\troot[\"chemEquilibrium\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 20);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0642bb1227aeb3e22563","'use strict';\n\nrequire('./symbol-species');\nvar abstractMatrix = require('./abstractMatrix');\nvar util = require('./util');\n\nclass Matrix extends abstractMatrix(Array) {\n    constructor(nRows, nColumns) {\n        var i;\n        if (arguments.length === 1 && typeof nRows === 'number') {\n            return new Array(nRows);\n        }\n        if (Matrix.isMatrix(nRows)) {\n            return nRows.clone();\n        } else if (Number.isInteger(nRows) && nRows > 0) { // Create an empty matrix\n            super(nRows);\n            if (Number.isInteger(nColumns) && nColumns > 0) {\n                for (i = 0; i < nRows; i++) {\n                    this[i] = new Array(nColumns);\n                }\n            } else {\n                throw new TypeError('nColumns must be a positive integer');\n            }\n        } else if (Array.isArray(nRows)) { // Copy the values from the 2D array\n            const matrix = nRows;\n            nRows = matrix.length;\n            nColumns = matrix[0].length;\n            if (typeof nColumns !== 'number' || nColumns === 0) {\n                throw new TypeError('Data must be a 2D array with at least one element');\n            }\n            super(nRows);\n            for (i = 0; i < nRows; i++) {\n                if (matrix[i].length !== nColumns) {\n                    throw new RangeError('Inconsistent array dimensions');\n                }\n                this[i] = [].concat(matrix[i]);\n            }\n        } else {\n            throw new TypeError('First argument must be a positive number or an array');\n        }\n        this.rows = nRows;\n        this.columns = nColumns;\n        return this;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this[rowIndex][columnIndex] = value;\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this[rowIndex][columnIndex];\n    }\n\n    /**\n     * Creates an exact and independent copy of the matrix\n     * @return {Matrix}\n     */\n    clone() {\n        var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);\n        for (var row = 0; row < this.rows; row++) {\n            for (var column = 0; column < this.columns; column++) {\n                newMatrix.set(row, column, this.get(row, column));\n            }\n        }\n        return newMatrix;\n    }\n\n    /**\n     * Removes a row from the given index\n     * @param {number} index - Row index\n     * @return {Matrix} this\n     */\n    removeRow(index) {\n        util.checkRowIndex(this, index);\n        if (this.rows === 1) {\n            throw new RangeError('A matrix cannot have less than one row');\n        }\n        this.splice(index, 1);\n        this.rows -= 1;\n        return this;\n    }\n\n    /**\n     * Adds a row at the given index\n     * @param {number} [index = this.rows] - Row index\n     * @param {Array|Matrix} array - Array or vector\n     * @return {Matrix} this\n     */\n    addRow(index, array) {\n        if (array === undefined) {\n            array = index;\n            index = this.rows;\n        }\n        util.checkRowIndex(this, index, true);\n        array = util.checkRowVector(this, array, true);\n        this.splice(index, 0, array);\n        this.rows += 1;\n        return this;\n    }\n\n    /**\n     * Removes a column from the given index\n     * @param {number} index - Column index\n     * @return {Matrix} this\n     */\n    removeColumn(index) {\n        util.checkColumnIndex(this, index);\n        if (this.columns === 1) {\n            throw new RangeError('A matrix cannot have less than one column');\n        }\n        for (var i = 0; i < this.rows; i++) {\n            this[i].splice(index, 1);\n        }\n        this.columns -= 1;\n        return this;\n    }\n\n    /**\n     * Adds a column at the given index\n     * @param {number} [index = this.columns] - Column index\n     * @param {Array|Matrix} array - Array or vector\n     * @return {Matrix} this\n     */\n    addColumn(index, array) {\n        if (typeof array === 'undefined') {\n            array = index;\n            index = this.columns;\n        }\n        util.checkColumnIndex(this, index, true);\n        array = util.checkColumnVector(this, array);\n        for (var i = 0; i < this.rows; i++) {\n            this[i].splice(index, 0, array[i]);\n        }\n        this.columns += 1;\n        return this;\n    }\n}\n\nexports.Matrix = Matrix;\nMatrix.abstractMatrix = abstractMatrix;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/matrix.js\n// module id = 0\n// module chunks = 0","'use strict';\n\nvar abstractMatrix = require('../abstractMatrix');\nvar Matrix = require('../matrix');\n\nclass BaseView extends abstractMatrix() {\n    constructor(matrix, rows, columns) {\n        super();\n        this.matrix = matrix;\n        this.rows = rows;\n        this.columns = columns;\n    }\n\n    static get [Symbol.species]() {\n        return Matrix.Matrix;\n    }\n}\n\nmodule.exports = BaseView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/base.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nvar Matrix = require('./matrix');\n\n/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexports.checkRowIndex = function checkRowIndex(matrix, index, outer) {\n    var max = outer ? matrix.rows : matrix.rows - 1;\n    if (index < 0 || index > max) {\n        throw new RangeError('Row index out of range');\n    }\n};\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexports.checkColumnIndex = function checkColumnIndex(matrix, index, outer) {\n    var max = outer ? matrix.columns : matrix.columns - 1;\n    if (index < 0 || index > max) {\n        throw new RangeError('Column index out of range');\n    }\n};\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexports.checkRowVector = function checkRowVector(matrix, vector) {\n    if (vector.to1DArray) {\n        vector = vector.to1DArray();\n    }\n    if (vector.length !== matrix.columns) {\n        throw new RangeError('vector size must be the same as the number of columns');\n    }\n    return vector;\n};\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexports.checkColumnVector = function checkColumnVector(matrix, vector) {\n    if (vector.to1DArray) {\n        vector = vector.to1DArray();\n    }\n    if (vector.length !== matrix.rows) {\n        throw new RangeError('vector size must be the same as the number of rows');\n    }\n    return vector;\n};\n\nexports.checkIndices = function checkIndices(matrix, rowIndices, columnIndices) {\n    var rowOut = rowIndices.some(r => {\n        return r < 0 || r >= matrix.rows;\n\n    });\n\n    var columnOut = columnIndices.some(c => {\n        return c < 0 || c >= matrix.columns;\n    });\n\n    if (rowOut || columnOut) {\n        throw new RangeError('Indices are out of range');\n    }\n\n    if (typeof rowIndices !== 'object' || typeof columnIndices !== 'object') {\n        throw new TypeError('Unexpected type for row/column indices');\n    }\n    if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n    if (!Array.isArray(columnIndices)) rowIndices = Array.from(columnIndices);\n\n    return {\n        row: rowIndices,\n        column: columnIndices\n    };\n};\n\nexports.checkRange = function checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n    if (arguments.length !== 5) throw new TypeError('Invalid argument type');\n    var notAllNumbers = Array.from(arguments).slice(1).some(function (arg) {\n        return typeof arg !== 'number';\n    });\n    if (notAllNumbers) throw new TypeError('Invalid argument type');\n    if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix.rows || endRow < 0 || endRow >= matrix.rows || startColumn < 0 || startColumn >= matrix.columns || endColumn < 0 || endColumn >= matrix.columns) {\n        throw new RangeError('Submatrix indices are out of range');\n    }\n};\n\nexports.getRange = function getRange(from, to) {\n    var arr = new Array(to - from + 1);\n    for (var i = 0; i < arr.length; i++) {\n        arr[i] = from + i;\n    }\n    return arr;\n};\n\nexports.sumByRow = function sumByRow(matrix) {\n    var sum = Matrix.Matrix.zeros(matrix.rows, 1);\n    for (var i = 0; i < matrix.rows; ++i) {\n        for (var j = 0; j < matrix.columns; ++j) {\n            sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));\n        }\n    }\n    return sum;\n};\n\nexports.sumByColumn = function sumByColumn(matrix) {\n    var sum = Matrix.Matrix.zeros(1, matrix.columns);\n    for (var i = 0; i < matrix.rows; ++i) {\n        for (var j = 0; j < matrix.columns; ++j) {\n            sum.set(0, j, sum.get(0, j) + matrix.get(i, j));\n        }\n    }\n    return sum;\n};\n\nexports.sumAll = function sumAll(matrix) {\n    var v = 0;\n    for (var i = 0; i < matrix.rows; i++) {\n        for (var j = 0; j < matrix.columns; j++) {\n            v += matrix.get(i, j);\n        }\n    }\n    return v;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/util.js\n// module id = 2\n// module chunks = 0","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nexports.hypotenuse = function hypotenuse(a, b) {\n    var r;\n    if (Math.abs(a) > Math.abs(b)) {\n        r = b / a;\n        return Math.abs(a) * Math.sqrt(1 + r * r);\n    }\n    if (b !== 0) {\n        r = a / b;\n        return Math.abs(b) * Math.sqrt(1 + r * r);\n    }\n    return 0;\n};\n\n// For use in the decomposition algorithms. With big matrices, access time is\n// too long on elements from array subclass\n// todo check when it is fixed in v8\n// http://jsperf.com/access-and-write-array-subclass\nexports.getEmpty2DArray = function (rows, columns) {\n    var array = new Array(rows);\n    for (var i = 0; i < rows; i++) {\n        array[i] = new Array(columns);\n    }\n    return array;\n};\n\nexports.getFilled2DArray = function (rows, columns, value) {\n    var array = new Array(rows);\n    for (var i = 0; i < rows; i++) {\n        array[i] = new Array(columns);\n        for (var j = 0; j < columns; j++) {\n            array[i][j] = value;\n        }\n    }\n    return array;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/util.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nexports.array = require('./array');\nexports.matrix = require('./matrix');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-stat/index.js\n// module id = 5\n// module chunks = 0","'use strict';\nconst Matrix = require('ml-matrix');\nconst random = require('./../util/random');\nconst newtonRaphton = require('./NewtonRaphton');\n\nconst defaultOptions = {\n    robustMaxTries: 10,\n    volume: 1,\n    random: Math.random,\n    autoInitial: true,\n    tolerance: 1e-15\n};\n\n/**\n * Equilibrium\n */\nclass Equilibrium {\n    /**\n     * @constructor\n     * @param {object} model\n     * amounts can be though as if they were concenrations.\n     * @param {object[]} model.components - The equilibrium's independent components. Each object in the array requires\n     * a label property and either a total property (for total amount) or an atEquilibrium property (for fixed final amount).\n     * The label property should be a unique name for that specie\n     *\n     * @param {object[]} model.formedSpecies - The list of species that are formed from the components. Each object\n     * in the array requires a label property, a beta property and a components property. The component property should be an array of numbers\n     * with the stoechiometric coefficient of each component using the order in which the components where specified. The beta property\n     * should be a number with the formation constant of this specie. The label property should be a unique name for that specie.\n     *\n     * @param {object} options - Additional options\n     * @param {number} [options.volume=1] - Volume of the solution in which the equilibrium occurs. If this value is 1 then\n     * @param {number} [options.robustMaxTries=15] - Maximum tries when using {@link #Equilibrium#solveRobust solveRobust}.\n     * @param {function} [options.random=Math.random] - Random number generator to use when initializing concentrations\n     */\n    constructor(model, options) {\n        this.options = Object.assign({}, defaultOptions, options);\n        checkModel(model);\n        this.model = model;\n        this._model = this._processModel(model);\n    }\n\n    /**\n     * Get initial values of components. Initial values that are not set by the user are choosen randomly\n     * @return {object} Object with two properties: solid with the initial solid \"concentrations\", component with\n     * the initial non-fixed components\n     * @private\n     */\n    _getInitial() {\n        // Return random inital value for all labels that don't have a fixed initial value\n        var keys = this._initial ? Object.keys(this._initial) : [];\n        var initial = new Array(this._model.nComp);\n        var initialSolid = new Array(this._model.specSolidLabels.length);\n\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var idx = this._model.compLabels.indexOf(key);\n            if (idx === -1) {\n                idx = this._model.specSolidLabels.indexOf(key);\n                if (idx !== -1) initialSolid[idx] = this._initial[key];\n            } else {\n                initial[idx] = this._initial[key];\n            }\n        }\n\n        for (i = 0; i < initial.length; i++) {\n            if (initial[i] === undefined) {\n                initial[i] = random.logarithmic(this.options.random);\n            }\n        }\n\n        for (i = 0; i < initialSolid.length; i++) {\n            if (initialSolid[i] === undefined) {\n                initialSolid[i] = random.logarithmic(this.options.random);\n            }\n        }\n\n        return {\n            components: initial,\n            solids: initialSolid\n        };\n    }\n\n    /**\n     * Process the model and get something readily usable by the optimization algorithm\n     * @param {object} model\n     * @return {{model: Array, beta: Array, cTotal: Array, cFixed: Array, specLabels: Array, compLabels: Array, fixedLabels: Array, nComp: (number|*), nSpec: (*|number), nFixed: number}}\n     * @private\n     */\n    _processModel(model) {\n        // change betas and model to reflect what should be\n        // optimized in newton raphton\n        // Initialize model\n        var nFormed = model.formedSpecies.length;\n        var nComp = model.components.length;\n        var nSpec = nComp + nFormed;\n        var nSpecSolution = count(model.formedSpecies, spec => !spec.solid);\n        var nSpecSolid = nSpec - nSpecSolution - nComp;\n\n        var formedSpeciesSolution = model.formedSpecies.filter(spec => !spec.solid);\n        var formedSpeciesSolid = model.formedSpecies.filter(spec => spec.solid);\n\n        // ========= init betas =====================================================================================\n        // The formation constants for components is always 1\n        var beta = new Matrix(1, nSpecSolution + nComp).fill(1);\n        // The other formation constants we pick from user\n        beta.setSubMatrix([formedSpeciesSolution.map(c => c.beta)], 0, nComp);\n        if (nSpecSolid) {\n            var solidBeta = new Matrix([formedSpeciesSolid.map(c => c.beta)]);\n        }\n\n\n        // =========== Init stoechiometric matrix (formed species in solution) =================================\n        // One line per component, one column per specie\n        // Species are components + formedSpecies\n\n        var matrix = new Matrix(nComp, nSpecSolution + nComp);\n        var identity = Matrix.identity(model.components.length);\n        matrix.setSubMatrix(identity, 0, 0);\n\n        // Now we modify the stoechiometric matrix if there are any components with fixed concentrations\n        // Fixed components are removed from the model and beta values of species are updated accordingly\n        var rows = [];\n        for (i = 0; i < nComp; i++) {\n            for (var j = 0; j < nSpecSolution; j++) {\n                matrix.set(i, j + nComp, formedSpeciesSolution[j].components[i]);\n            }\n        }\n\n        for (i = 0; i < nComp; i++) {\n            // Fixed components have the atEquilibrium property set\n            var atEq = model.components[i].atEquilibrium;\n            if (!atEq) {\n                // Keep this component in the final model\n                rows.push(i);\n            } else {\n                // Update the beta value of all species\n                // newBeta = oldBeta * fixedComponentConcentration^(stoechiometricCoefficient)\n                var m = new Matrix(1, nSpecSolution + nComp).fill(atEq);\n                m.pow([matrix.getRow(i)]);\n                beta.multiply(m);\n            }\n        }\n\n        // remove fixed components from beta and stoechiometric matrix\n        var columns = rows.concat(getRange(nComp, nComp + nSpecSolution - 1));\n        matrix = matrix.selection(rows, columns);\n        beta = beta.selection([0], columns);\n        // remove empty columns\n        // var notZeroColumns = [];\n        // loop1: for(var i=0; i<matrix.columns; i++) {\n        //     for(var j=0; j<matrix.rows; j++) {\n        //         if(matrix[j][i] !== 0) {\n        //             notZeroColumns.push(i);\n        //             continue loop1;\n        //         }\n        //     }\n        // }\n        // matrix = matrix.selection(getRange(0, matrix.rows - 1), notZeroColumns);\n        // beta = beta.selection([0], notZeroColumns);\n\n        // ============= Init stoechiometric matrix (formed solids) ================================================\n        if (nSpecSolid) {\n            rows = [];\n            var solidMatrix = new Matrix(nComp, nSpecSolid);\n            for (i = 0; i < nComp; i++) {\n                for (j = 0; j < nSpecSolid; j++) {\n                    solidMatrix.set(i, j, formedSpeciesSolid[j].components[i]);\n                }\n            }\n\n            for (i = 0; i < nComp; i++) {\n                // Fixed components have the atEquilibrium property set\n                atEq = model.components[i].atEquilibrium;\n                if (!atEq) {\n                    // Keep this component in the final model\n                    rows.push(i);\n                } else {\n                    // Update the beta value of all species\n                    // newBeta = oldBeta * fixedComponentConcentration^(stoechiometricCoefficient)\n                    m = new Matrix(1, nSpecSolid).fill(atEq);\n                    m.pow([solidMatrix.getRow(i)]);\n                    solidBeta.multiply(m);\n                }\n            }\n\n            // remove fixed components from beta and stoechiometric matrix\n            columns = getRange(0, nSpecSolid - 1);\n            solidMatrix = solidMatrix.selection(rows, columns);\n            solidBeta = solidBeta.selection([0], columns);\n            // newtonRaphton uses the dissociaton Ksp, not the formation Ksp\n            solidBeta.pow(-1);\n        }\n\n\n        // ============= Labels and concentrations ==================================================================\n        var specLabels = [];\n        var fixedLabels = [];\n        var cFixed = [];\n        var compLabels = [];\n\n        // Init labels and total concentration\n        var cTotal = [];\n        for (var i = 0; i < nComp; i++) {\n            var component = model.components[i];\n            if (component.atEquilibrium) {\n                // Keep concentration and label of fixed components\n                fixedLabels.push(component.label);\n                cFixed.push(component.atEquilibrium / this.options.volume);\n            } else {\n                // Total concentration of components that will be involved in the optimization algorithm\n                cTotal.push(component.total / this.options.volume);\n                specLabels.push(component.label);\n                compLabels.push(component.label);\n            }\n        }\n\n        var specSolutionLabels = formedSpeciesSolution.map(s => s.label);\n        var specSolidLabels = formedSpeciesSolid.map(s => s.label);\n        specLabels = specLabels.concat(specSolutionLabels, specSolidLabels);\n\n        return {\n            model: matrix.to2DArray(),\n            beta: beta.to1DArray(),\n            cTotal: cTotal,\n            cFixed: cFixed,\n            specLabels,\n            compLabels,\n            fixedLabels,\n            specSolidLabels,\n            specSolutionLabels,\n            nFixed: nComp - matrix.rows,\n            solidModel: solidMatrix && solidMatrix.to2DArray(),\n            solidBeta: solidBeta && solidBeta.to1DArray()\n        };\n    }\n\n    /**\n     * Solve the model. Initial concentrations set with {@link Equilibrium#setInitial setInitial} will be used as the\n     * starting points of the optimization algorithm.\n     * @return {object} An Object with as many properties as there are species. The key is the label of the specie,\n     * and the value is the concentration at equilibrium of this specie.\n     */\n    solve() {\n        var model = this._model;\n        var initial = this._getInitial();\n        var cSpec = newtonRaphton(model.model, model.beta, model.cTotal, initial.components, model.solidModel, model.solidBeta, initial.solids, this.options);\n        var result = this._processResult(cSpec);\n        if (this.options.autoInitial) this.setInitial(result);\n        return result;\n    }\n\n    /**\n     * Solve the model robustly. Does not take into account initial concentrations set with {@link #Equilibrium#setInitial setInitial}\n     * Random initialization concentrations are used until the optimization algorithm converges. The number of tries\n     * is set at instanciation with robustMaxTries\n     * @return {object|null} An Object with as many properties as there are species. The key is the label of the specie,\n     * and the value is the concentration at equilibrium of this specie.\n     */\n    solveRobust() {\n        var model = this._model;\n        for (var i = 0; i < this.options.robustMaxTries; i++) {\n            var initial = {\n                components: random.logarithmic(this.options.random, model.compLabels.length),\n                solids: random.logarithmic(this.options.random, model.specSolidLabels.length)\n            };\n            var cSpec = newtonRaphton(model.model, model.beta, model.cTotal, initial.components, model.solidModel, model.solidBeta, initial.solids, this.options);\n            if (cSpec) {\n                return this._processResult(cSpec);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Set initial concentration of components\n     * @param {object} init - Object where the key is the label of the component and the value is the initial\n     * amount (in moles) of this components.\n     */\n    setInitial(init) {\n        var initial = Object.assign({}, init);\n        var keys = Object.keys(initial);\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (initial[key] === 0) initial[key] = 1e-15;\n        }\n        this._initial = initial;\n    }\n\n    /**\n     * Transforms array of specie concentrations into object where the key is the specie label.\n     * Adds the fixed concentrations to it\n     * @param {Array} cSpec - Array of specie concentrations\n     * @return {object} Object where key is the specie label and value is the concentration\n     * @private\n     */\n    _processResult(cSpec) {\n        if (!cSpec) return null;\n        var result = {};\n        for (var i = 0; i < this._model.specLabels.length; i++) {\n            result[this._model.specLabels[i]] = cSpec[i];\n        }\n\n\n        for (i = 0; i < this._model.cFixed.length; i++) {\n            result[this._model.fixedLabels[i]] = this._model.cFixed[i];\n        }\n\n        return result;\n    }\n}\n\nmodule.exports = Equilibrium;\n\nfunction getRange(start, end) {\n    var arr = [];\n    for (var i = start; i <= end; i++) {\n        arr.push(i);\n    }\n    return arr;\n}\n\nfunction checkModel(model) {\n    // check that labels are unique\n    var labels = {};\n    checkLabels(model.formedSpecies, labels);\n    checkLabels(model.components, labels);\n    checkComponents(model.components);\n    checkFormedSpecies(model);\n}\n\nfunction checkLabels(arr, labels) {\n    for (var i = 0; i < arr.length; i++) {\n        var label = arr[i].label;\n        if (label === undefined || label === null) throw new Error('Labels must be defined');\n        if (labels[label]) throw new Error('Labels should be unique');\n        labels[label] = true;\n    }\n}\n\nfunction checkComponents(comp) {\n    for (var i = 0; i < comp.length; i++) {\n        if (typeof comp[i].total !== 'number' && typeof comp[i].atEquilibrium !== 'number') {\n            throw new Error('Component should have a property total or atEquilibrium that is a number');\n        }\n    }\n}\n\nfunction checkFormedSpecies(model) {\n    var spec = model.formedSpecies;\n    if (!spec) throw new Error('Formed species is not defined');\n    for (var i = 0; i < spec.length; i++) {\n        var s = spec[i];\n        if (!s.components || s.components.length !== model.components.length) {\n            throw new Error('Formed species\\' components array should have the same size as components');\n        }\n        if (typeof s.beta !== 'number') {\n            throw new Error('All formed species should have a beta property');\n        }\n    }\n}\n\nfunction count(arr, cb) {\n    var count = 0;\n    for (var i = 0; i < arr.length; i++) {\n        if (cb(arr[i])) ++count;\n    }\n    return count;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/Equilibrium.js","module.exports = require('./lib');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deepcopy/index.js\n// module id = 7\n// module chunks = 0","'use strict';\n\nexports.__esModule = true;\nvar toString = Object.prototype.toString;\n\nvar isBuffer = typeof Buffer !== 'undefined' ? function isBuffer(obj) {\n  return Buffer.isBuffer(obj);\n} : function isBuffer() {\n  // always return false in browsers\n  return false;\n};\n\nvar getKeys = typeof Object.keys === 'function' ? function getKeys(obj) {\n  return Object.keys(obj);\n} : function getKeys(obj) {\n  var objType = typeof obj;\n\n  if (obj === null || objType !== 'function' && objType !== 'object') {\n    throw new TypeError('obj must be an Object');\n  }\n\n  var resultKeys = [],\n      key = void 0;\n\n  for (key in obj) {\n    Object.prototype.hasOwnProperty.call(obj, key) && resultKeys.push(key);\n  }\n\n  return resultKeys;\n};\n\nvar getSymbols = typeof Symbol === 'function' ? function getSymbols(obj) {\n  return Object.getOwnPropertySymbols(obj);\n} : function getSymbols() {\n  // always return empty Array when Symbol is not supported\n  return [];\n};\n\n// NOTE:\n//\n//   Array.prototype.indexOf is cannot find NaN (in Chrome)\n//   Array.prototype.includes is can find NaN (in Chrome)\n//\n//   this function can find NaN, because use SameValue algorithm\nfunction indexOf(array, s) {\n  if (toString.call(array) !== '[object Array]') {\n    throw new TypeError('array must be an Array');\n  }\n\n  var i = void 0,\n      len = void 0,\n      value = void 0;\n\n  for (i = 0, len = array.length; i < len; ++i) {\n    value = array[i];\n\n    // NOTE:\n    //\n    //   it is SameValue algorithm\n    //   http://stackoverflow.com/questions/27144277/comparing-a-variable-with-itself\n    //\n    // eslint-disable-next-line no-self-compare\n    if (value === s || value !== value && s !== s) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nexports.getKeys = getKeys;\nexports.getSymbols = getSymbols;\nexports.indexOf = indexOf;\nexports.isBuffer = isBuffer;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deepcopy/lib/polyfill.js\n// module id = 8\n// module chunks = 0","'use strict';\n\nmodule.exports = abstractMatrix;\n\nvar LuDecomposition = require('./dc/lu');\nvar SvDecomposition = require('./dc/svd');\nvar arrayUtils = require('ml-array-utils');\nvar util = require('./util');\nvar MatrixTransposeView = require('./views/transpose');\nvar MatrixRowView = require('./views/row');\nvar MatrixSubView = require('./views/sub');\nvar MatrixSelectionView = require('./views/selection');\nvar MatrixColumnView = require('./views/column');\nvar MatrixFlipRowView = require('./views/flipRow');\nvar MatrixFlipColumnView = require('./views/flipColumn');\n\nfunction abstractMatrix(superCtor) {\n    if (superCtor === undefined) superCtor = Object;\n\n    /**\n     * Real matrix\n     * @class Matrix\n     * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,\n     * 2D array containing the data or Matrix instance to clone\n     * @param {number} [nColumns] - Number of columns of the new matrix\n     */\n    class Matrix extends superCtor {\n        static get [Symbol.species]() {\n            return this;\n        }\n\n        /**\n         * Constructs a Matrix with the chosen dimensions from a 1D array\n         * @param {number} newRows - Number of rows\n         * @param {number} newColumns - Number of columns\n         * @param {Array} newData - A 1D array containing data for the matrix\n         * @return {Matrix} - The new matrix\n         */\n        static from1DArray(newRows, newColumns, newData) {\n            var length = newRows * newColumns;\n            if (length !== newData.length) {\n                throw new RangeError('Data length does not match given dimensions');\n            }\n            var newMatrix = new this(newRows, newColumns);\n            for (var row = 0; row < newRows; row++) {\n                for (var column = 0; column < newColumns; column++) {\n                    newMatrix.set(row, column, newData[row * newColumns + column]);\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Creates a row vector, a matrix with only one row.\n         * @param {Array} newData - A 1D array containing data for the vector\n         * @return {Matrix} - The new matrix\n         */\n        static rowVector(newData) {\n            var vector = new this(1, newData.length);\n            for (var i = 0; i < newData.length; i++) {\n                vector.set(0, i, newData[i]);\n            }\n            return vector;\n        }\n\n        /**\n         * Creates a column vector, a matrix with only one column.\n         * @param {Array} newData - A 1D array containing data for the vector\n         * @return {Matrix} - The new matrix\n         */\n        static columnVector(newData) {\n            var vector = new this(newData.length, 1);\n            for (var i = 0; i < newData.length; i++) {\n                vector.set(i, 0, newData[i]);\n            }\n            return vector;\n        }\n\n        /**\n         * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @return {Matrix} - The new matrix\n         */\n        static empty(rows, columns) {\n            return new this(rows, columns);\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be set to zero.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @return {Matrix} - The new matrix\n         */\n        static zeros(rows, columns) {\n            return this.empty(rows, columns).fill(0);\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be set to one.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @return {Matrix} - The new matrix\n         */\n        static ones(rows, columns) {\n            return this.empty(rows, columns).fill(1);\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be randomly set.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @param {function} [rng=Math.random] - Random number generator\n         * @return {Matrix} The new matrix\n         */\n        static rand(rows, columns, rng) {\n            if (rng === undefined) rng = Math.random;\n            var matrix = this.empty(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    matrix.set(i, j, rng());\n                }\n            }\n            return matrix;\n        }\n\n        /**\n         * Creates a matrix with the given dimensions. Values will be random integers.\n         * @param {number} rows - Number of rows\n         * @param {number} columns - Number of columns\n         * @param {number} [maxValue=1000] - Maximum value\n         * @param {function} [rng=Math.random] - Random number generator\n         * @return {Matrix} The new matrix\n         */\n        static randInt(rows, columns, maxValue, rng) {\n            if (maxValue === undefined) maxValue = 1000;\n            if (rng === undefined) rng = Math.random;\n            var matrix = this.empty(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    var value = Math.floor(rng() * maxValue);\n                    matrix.set(i, j, value);\n                }\n            }\n            return matrix;\n        }\n\n        /**\n         * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.\n         * @param {number} rows - Number of rows\n         * @param {number} [columns=rows] - Number of columns\n         * @param {number} [value=1] - Value to fill the diagonal with\n         * @return {Matrix} - The new identity matrix\n         */\n        static eye(rows, columns, value) {\n            if (columns === undefined) columns = rows;\n            if (value === undefined) value = 1;\n            var min = Math.min(rows, columns);\n            var matrix = this.zeros(rows, columns);\n            for (var i = 0; i < min; i++) {\n                matrix.set(i, i, value);\n            }\n            return matrix;\n        }\n\n        /**\n         * Creates a diagonal matrix based on the given array.\n         * @param {Array} data - Array containing the data for the diagonal\n         * @param {number} [rows] - Number of rows (Default: data.length)\n         * @param {number} [columns] - Number of columns (Default: rows)\n         * @return {Matrix} - The new diagonal matrix\n         */\n        static diag(data, rows, columns) {\n            var l = data.length;\n            if (rows === undefined) rows = l;\n            if (columns === undefined) columns = rows;\n            var min = Math.min(l, rows, columns);\n            var matrix = this.zeros(rows, columns);\n            for (var i = 0; i < min; i++) {\n                matrix.set(i, i, data[i]);\n            }\n            return matrix;\n        }\n\n        /**\n         * Returns a matrix whose elements are the minimum between matrix1 and matrix2\n         * @param {Matrix} matrix1\n         * @param {Matrix} matrix2\n         * @return {Matrix}\n         */\n        static min(matrix1, matrix2) {\n            matrix1 = this.checkMatrix(matrix1);\n            matrix2 = this.checkMatrix(matrix2);\n            var rows = matrix1.rows;\n            var columns = matrix1.columns;\n            var result = new this(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Returns a matrix whose elements are the maximum between matrix1 and matrix2\n         * @param {Matrix} matrix1\n         * @param {Matrix} matrix2\n         * @return {Matrix}\n         */\n        static max(matrix1, matrix2) {\n            matrix1 = this.checkMatrix(matrix1);\n            matrix2 = this.checkMatrix(matrix2);\n            var rows = matrix1.rows;\n            var columns = matrix1.columns;\n            var result = new this(rows, columns);\n            for (var i = 0; i < rows; i++) {\n                for (var j = 0; j < columns; j++) {\n                    result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Check that the provided value is a Matrix and tries to instantiate one if not\n         * @param {*} value - The value to check\n         * @return {Matrix}\n         */\n        static checkMatrix(value) {\n            return Matrix.isMatrix(value) ? value : new this(value);\n        }\n\n        /**\n         * Returns true if the argument is a Matrix, false otherwise\n         * @param {*} value - The value to check\n         * @return {boolean}\n         */\n        static isMatrix(value) {\n            return (value != null) && (value.klass === 'Matrix');\n        }\n\n        /**\n         * @prop {number} size - The number of elements in the matrix.\n         */\n        get size() {\n            return this.rows * this.columns;\n        }\n\n        /**\n         * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\n         * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\n         * @return {Matrix} this\n         */\n        apply(callback) {\n            if (typeof callback !== 'function') {\n                throw new TypeError('callback must be a function');\n            }\n            var ii = this.rows;\n            var jj = this.columns;\n            for (var i = 0; i < ii; i++) {\n                for (var j = 0; j < jj; j++) {\n                    callback.call(this, i, j);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Returns a new 1D array filled row by row with the matrix values\n         * @return {Array}\n         */\n        to1DArray() {\n            var array = new Array(this.size);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    array[i * this.columns + j] = this.get(i, j);\n                }\n            }\n            return array;\n        }\n\n        /**\n         * Returns a 2D array containing a copy of the data\n         * @return {Array}\n         */\n        to2DArray() {\n            var copy = new Array(this.rows);\n            for (var i = 0; i < this.rows; i++) {\n                copy[i] = new Array(this.columns);\n                for (var j = 0; j < this.columns; j++) {\n                    copy[i][j] = this.get(i, j);\n                }\n            }\n            return copy;\n        }\n\n        /**\n         * @return {boolean} true if the matrix has one row\n         */\n        isRowVector() {\n            return this.rows === 1;\n        }\n\n        /**\n         * @return {boolean} true if the matrix has one column\n         */\n        isColumnVector() {\n            return this.columns === 1;\n        }\n\n        /**\n         * @return {boolean} true if the matrix has one row or one column\n         */\n        isVector() {\n            return (this.rows === 1) || (this.columns === 1);\n        }\n\n        /**\n         * @return {boolean} true if the matrix has the same number of rows and columns\n         */\n        isSquare() {\n            return this.rows === this.columns;\n        }\n\n        /**\n         * @return {boolean} true if the matrix is square and has the same values on both sides of the diagonal\n         */\n        isSymmetric() {\n            if (this.isSquare()) {\n                for (var i = 0; i < this.rows; i++) {\n                    for (var j = 0; j <= i; j++) {\n                        if (this.get(i, j) !== this.get(j, i)) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\n         * @abstract\n         * @param {number} rowIndex - Index of the row\n         * @param {number} columnIndex - Index of the column\n         * @param {number} value - The new value for the element\n         * @return {Matrix} this\n         */\n        set(rowIndex, columnIndex, value) { // eslint-disable-line no-unused-vars\n            throw new Error('set method is unimplemented');\n        }\n\n        /**\n         * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\n         * @abstract\n         * @param {number} rowIndex - Index of the row\n         * @param {number} columnIndex - Index of the column\n         * @return {number}\n         */\n        get(rowIndex, columnIndex) { // eslint-disable-line no-unused-vars\n            throw new Error('get method is unimplemented');\n        }\n\n        /**\n         * Creates a new matrix that is a repetition of the current matrix. New matrix has rowRep times the number of\n         * rows of the matrix, and colRep times the number of columns of the matrix\n         * @param {number} rowRep - Number of times the rows should be repeated\n         * @param {number} colRep - Number of times the columns should be re\n         * @return {Matrix}\n         * @example\n         * var matrix = new Matrix([[1,2]]);\n         * matrix.repeat(2); // [[1,2],[1,2]]\n         */\n        repeat(rowRep, colRep) {\n            rowRep = rowRep || 1;\n            colRep = colRep || 1;\n            var matrix = new this.constructor[Symbol.species](this.rows * rowRep, this.columns * colRep);\n            for (var i = 0; i < rowRep; i++) {\n                for (var j = 0; j < colRep; j++) {\n                    matrix.setSubMatrix(this, this.rows * i, this.columns * j);\n                }\n            }\n            return matrix;\n        }\n\n        /**\n         * Fills the matrix with a given value. All elements will be set to this value.\n         * @param {number} value - New value\n         * @return {Matrix} this\n         */\n        fill(value) {\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, value);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Negates the matrix. All elements will be multiplied by (-1)\n         * @return {Matrix} this\n         */\n        neg() {\n            return this.mulS(-1);\n        }\n\n        /**\n         * Returns a new array from the given row index\n         * @param {number} index - Row index\n         * @return {Array}\n         */\n        getRow(index) {\n            util.checkRowIndex(this, index);\n            var row = new Array(this.columns);\n            for (var i = 0; i < this.columns; i++) {\n                row[i] = this.get(index, i);\n            }\n            return row;\n        }\n\n        /**\n         * Returns a new row vector from the given row index\n         * @param {number} index - Row index\n         * @return {Matrix}\n         */\n        getRowVector(index) {\n            return this.constructor.rowVector(this.getRow(index));\n        }\n\n        /**\n         * Sets a row at the given index\n         * @param {number} index - Row index\n         * @param {Array|Matrix} array - Array or vector\n         * @return {Matrix} this\n         */\n        setRow(index, array) {\n            util.checkRowIndex(this, index);\n            array = util.checkRowVector(this, array);\n            for (var i = 0; i < this.columns; i++) {\n                this.set(index, i, array[i]);\n            }\n            return this;\n        }\n\n        /**\n         * Swaps two rows\n         * @param {number} row1 - First row index\n         * @param {number} row2 - Second row index\n         * @return {Matrix} this\n         */\n        swapRows(row1, row2) {\n            util.checkRowIndex(this, row1);\n            util.checkRowIndex(this, row2);\n            for (var i = 0; i < this.columns; i++) {\n                var temp = this.get(row1, i);\n                this.set(row1, i, this.get(row2, i));\n                this.set(row2, i, temp);\n            }\n            return this;\n        }\n\n        /**\n         * Returns a new array from the given column index\n         * @param {number} index - Column index\n         * @return {Array}\n         */\n        getColumn(index) {\n            util.checkColumnIndex(this, index);\n            var column = new Array(this.rows);\n            for (var i = 0; i < this.rows; i++) {\n                column[i] = this.get(i, index);\n            }\n            return column;\n        }\n\n        /**\n         * Returns a new column vector from the given column index\n         * @param {number} index - Column index\n         * @return {Matrix}\n         */\n        getColumnVector(index) {\n            return this.constructor.columnVector(this.getColumn(index));\n        }\n\n        /**\n         * Sets a column at the given index\n         * @param {number} index - Column index\n         * @param {Array|Matrix} array - Array or vector\n         * @return {Matrix} this\n         */\n        setColumn(index, array) {\n            util.checkColumnIndex(this, index);\n            array = util.checkColumnVector(this, array);\n            for (var i = 0; i < this.rows; i++) {\n                this.set(i, index, array[i]);\n            }\n            return this;\n        }\n\n        /**\n         * Swaps two columns\n         * @param {number} column1 - First column index\n         * @param {number} column2 - Second column index\n         * @return {Matrix} this\n         */\n        swapColumns(column1, column2) {\n            util.checkColumnIndex(this, column1);\n            util.checkColumnIndex(this, column2);\n            for (var i = 0; i < this.rows; i++) {\n                var temp = this.get(i, column1);\n                this.set(i, column1, this.get(i, column2));\n                this.set(i, column2, temp);\n            }\n            return this;\n        }\n\n        /**\n         * Adds the values of a vector to each row\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        addRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) + vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Subtracts the values of a vector from each row\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        subRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) - vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a vector with each row\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        mulRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) * vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Divides the values of each row by those of a vector\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        divRowVector(vector) {\n            vector = util.checkRowVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) / vector[j]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Adds the values of a vector to each column\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        addColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) + vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Subtracts the values of a vector from each column\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        subColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) - vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a vector with each column\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        mulColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) * vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Divides the values of each column by those of a vector\n         * @param {Array|Matrix} vector - Array or vector\n         * @return {Matrix} this\n         */\n        divColumnVector(vector) {\n            vector = util.checkColumnVector(this, vector);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    this.set(i, j, this.get(i, j) / vector[i]);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a row with a scalar\n         * @param {number} index - Row index\n         * @param {number} value\n         * @return {Matrix} this\n         */\n        mulRow(index, value) {\n            util.checkRowIndex(this, index);\n            for (var i = 0; i < this.columns; i++) {\n                this.set(index, i, this.get(index, i) * value);\n            }\n            return this;\n        }\n\n        /**\n         * Multiplies the values of a column with a scalar\n         * @param {number} index - Column index\n         * @param {number} value\n         * @return {Matrix} this\n         */\n        mulColumn(index, value) {\n            util.checkColumnIndex(this, index);\n            for (var i = 0; i < this.rows; i++) {\n                this.set(i, index, this.get(i, index) * value);\n            }\n            return this;\n        }\n\n        /**\n         * Returns the maximum value of the matrix\n         * @return {number}\n         */\n        max() {\n            var v = this.get(0, 0);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) > v) {\n                        v = this.get(i, j);\n                    }\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value\n         * @return {Array}\n         */\n        maxIndex() {\n            var v = this.get(0, 0);\n            var idx = [0, 0];\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) > v) {\n                        v = this.get(i, j);\n                        idx[0] = i;\n                        idx[1] = j;\n                    }\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the minimum value of the matrix\n         * @return {number}\n         */\n        min() {\n            var v = this.get(0, 0);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) < v) {\n                        v = this.get(i, j);\n                    }\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the minimum value\n         * @return {Array}\n         */\n        minIndex() {\n            var v = this.get(0, 0);\n            var idx = [0, 0];\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    if (this.get(i, j) < v) {\n                        v = this.get(i, j);\n                        idx[0] = i;\n                        idx[1] = j;\n                    }\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the maximum value of one row\n         * @param {number} row - Row index\n         * @return {number}\n         */\n        maxRow(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) > v) {\n                    v = this.get(row, i);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value of one row\n         * @param {number} row - Row index\n         * @return {Array}\n         */\n        maxRowIndex(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            var idx = [row, 0];\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) > v) {\n                    v = this.get(row, i);\n                    idx[1] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the minimum value of one row\n         * @param {number} row - Row index\n         * @return {number}\n         */\n        minRow(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) < v) {\n                    v = this.get(row, i);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value of one row\n         * @param {number} row - Row index\n         * @return {Array}\n         */\n        minRowIndex(row) {\n            util.checkRowIndex(this, row);\n            var v = this.get(row, 0);\n            var idx = [row, 0];\n            for (var i = 1; i < this.columns; i++) {\n                if (this.get(row, i) < v) {\n                    v = this.get(row, i);\n                    idx[1] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the maximum value of one column\n         * @param {number} column - Column index\n         * @return {number}\n         */\n        maxColumn(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) > v) {\n                    v = this.get(i, column);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the maximum value of one column\n         * @param {number} column - Column index\n         * @return {Array}\n         */\n        maxColumnIndex(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            var idx = [0, column];\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) > v) {\n                    v = this.get(i, column);\n                    idx[0] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns the minimum value of one column\n         * @param {number} column - Column index\n         * @return {number}\n         */\n        minColumn(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) < v) {\n                    v = this.get(i, column);\n                }\n            }\n            return v;\n        }\n\n        /**\n         * Returns the index of the minimum value of one column\n         * @param {number} column - Column index\n         * @return {Array}\n         */\n        minColumnIndex(column) {\n            util.checkColumnIndex(this, column);\n            var v = this.get(0, column);\n            var idx = [0, column];\n            for (var i = 1; i < this.rows; i++) {\n                if (this.get(i, column) < v) {\n                    v = this.get(i, column);\n                    idx[0] = i;\n                }\n            }\n            return idx;\n        }\n\n        /**\n         * Returns an array containing the diagonal values of the matrix\n         * @return {Array}\n         */\n        diag() {\n            var min = Math.min(this.rows, this.columns);\n            var diag = new Array(min);\n            for (var i = 0; i < min; i++) {\n                diag[i] = this.get(i, i);\n            }\n            return diag;\n        }\n\n        /**\n         * Returns the sum by the argument given, if no argument given,\n         * it returns the sum of all elements of the matrix.\n         * @param {string} by - sum by 'row' or 'column'.\n         * @return {Matrix|number}\n         */\n        sum(by) {\n            switch (by) {\n                case 'row':\n                    return util.sumByRow(this);\n                case 'column':\n                    return util.sumByColumn(this);\n                default:\n                    return util.sumAll(this);\n            }\n        }\n\n        /**\n         * Returns the mean of all elements of the matrix\n         * @return {number}\n         */\n        mean() {\n            return this.sum() / this.size;\n        }\n\n        /**\n         * Returns the product of all elements of the matrix\n         * @return {number}\n         */\n        prod() {\n            var prod = 1;\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    prod *= this.get(i, j);\n                }\n            }\n            return prod;\n        }\n\n        /**\n         * Computes the cumulative sum of the matrix elements (in place, row by row)\n         * @return {Matrix} this\n         */\n        cumulativeSum() {\n            var sum = 0;\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    sum += this.get(i, j);\n                    this.set(i, j, sum);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Computes the dot (scalar) product between the matrix and another\n         * @param {Matrix} vector2 vector\n         * @return {number}\n         */\n        dot(vector2) {\n            if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\n            var vector1 = this.to1DArray();\n            if (vector1.length !== vector2.length) {\n                throw new RangeError('vectors do not have the same size');\n            }\n            var dot = 0;\n            for (var i = 0; i < vector1.length; i++) {\n                dot += vector1[i] * vector2[i];\n            }\n            return dot;\n        }\n\n        /**\n         * Returns the matrix product between this and other\n         * @param {Matrix} other\n         * @return {Matrix}\n         */\n        mmul(other) {\n            other = this.constructor.checkMatrix(other);\n            if (this.columns !== other.rows) {\n                // eslint-disable-next-line no-console\n                console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\n            }\n\n            var m = this.rows;\n            var n = this.columns;\n            var p = other.columns;\n\n            var result = new this.constructor[Symbol.species](m, p);\n\n            var Bcolj = new Array(n);\n            for (var j = 0; j < p; j++) {\n                for (var k = 0; k < n; k++) {\n                    Bcolj[k] = other.get(k, j);\n                }\n\n                for (var i = 0; i < m; i++) {\n                    var s = 0;\n                    for (k = 0; k < n; k++) {\n                        s += this.get(i, k) * Bcolj[k];\n                    }\n\n                    result.set(i, j, s);\n                }\n            }\n            return result;\n        }\n\n        strassen2x2(other) {\n            var result = new this.constructor[Symbol.species](2, 2);\n            const a11 = this.get(0, 0);\n            const b11 = other.get(0, 0);\n            const a12 = this.get(0, 1);\n            const b12 = other.get(0, 1);\n            const a21 = this.get(1, 0);\n            const b21 = other.get(1, 0);\n            const a22 = this.get(1, 1);\n            const b22 = other.get(1, 1);\n\n            // Compute intermediate values.\n            const m1 = (a11 + a22) * (b11 + b22);\n            const m2 = (a21 + a22) * b11;\n            const m3 = a11 * (b12 - b22);\n            const m4 = a22 * (b21 - b11);\n            const m5 = (a11 + a12) * b22;\n            const m6 = (a21 - a11) * (b11 + b12);\n            const m7 = (a12 - a22) * (b21 + b22);\n\n            // Combine intermediate values into the output.\n            const c00 = m1 + m4 - m5 + m7;\n            const c01 = m3 + m5;\n            const c10 = m2 + m4;\n            const c11 = m1 - m2 + m3 + m6;\n\n            result.set(0, 0, c00);\n            result.set(0, 1, c01);\n            result.set(1, 0, c10);\n            result.set(1, 1, c11);\n            return result;\n        }\n\n        strassen3x3(other) {\n            var result = new this.constructor[Symbol.species](3, 3);\n\n            const a00 = this.get(0, 0);\n            const a01 = this.get(0, 1);\n            const a02 = this.get(0, 2);\n            const a10 = this.get(1, 0);\n            const a11 = this.get(1, 1);\n            const a12 = this.get(1, 2);\n            const a20 = this.get(2, 0);\n            const a21 = this.get(2, 1);\n            const a22 = this.get(2, 2);\n\n            const b00 = other.get(0, 0);\n            const b01 = other.get(0, 1);\n            const b02 = other.get(0, 2);\n            const b10 = other.get(1, 0);\n            const b11 = other.get(1, 1);\n            const b12 = other.get(1, 2);\n            const b20 = other.get(2, 0);\n            const b21 = other.get(2, 1);\n            const b22 = other.get(2, 2);\n\n            const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\n            const m2 = (a00 - a10) * (-b01 + b11);\n            const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\n            const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\n            const m5 = (a10 + a11) * (-b00 + b01);\n            const m6 = a00 * b00;\n            const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\n            const m8 = (-a00 + a20) * (b02 - b12);\n            const m9 = (a20 + a21) * (-b00 + b02);\n            const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\n            const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\n            const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\n            const m13 = (a02 - a22) * (b11 - b21);\n            const m14 = a02 * b20;\n            const m15 = (a21 + a22) * (-b20 + b21);\n            const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\n            const m17 = (a02 - a12) * (b12 - b22);\n            const m18 = (a11 + a12) * (-b20 + b22);\n            const m19 = a01 * b10;\n            const m20 = a12 * b21;\n            const m21 = a10 * b02;\n            const m22 = a20 * b01;\n            const m23 = a22 * b22;\n\n            const c00 = m6 + m14 + m19;\n            const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\n            const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\n            const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\n            const c11 = m2 + m4 + m5 + m6 + m20;\n            const c12 = m14 + m16 + m17 + m18 + m21;\n            const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\n            const c21 = m12 + m13 + m14 + m15 + m22;\n            const c22 = m6 + m7 + m8 + m9 + m23;\n\n            result.set(0, 0, c00);\n            result.set(0, 1, c01);\n            result.set(0, 2, c02);\n            result.set(1, 0, c10);\n            result.set(1, 1, c11);\n            result.set(1, 2, c12);\n            result.set(2, 0, c20);\n            result.set(2, 1, c21);\n            result.set(2, 2, c22);\n            return result;\n        }\n\n        /**\n         * Returns the matrix product between x and y. More efficient than mmul(other) only when we multiply squared matrix and when the size of the matrix is > 1000.\n         * @param {Matrix} y\n         * @return {Matrix}\n         */\n        mmulStrassen(y) {\n            var x = this.clone();\n            var r1 = x.rows;\n            var c1 = x.columns;\n            var r2 = y.rows;\n            var c2 = y.columns;\n            if (c1 !== r2) {\n                // eslint-disable-next-line no-console\n                console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);\n            }\n\n            // Put a matrix into the top left of a matrix of zeros.\n            // `rows` and `cols` are the dimensions of the output matrix.\n            function embed(mat, rows, cols) {\n                var r = mat.rows;\n                var c = mat.columns;\n                if ((r === rows) && (c === cols)) {\n                    return mat;\n                } else {\n                    var resultat = Matrix.zeros(rows, cols);\n                    resultat = resultat.setSubMatrix(mat, 0, 0);\n                    return resultat;\n                }\n            }\n\n\n            // Make sure both matrices are the same size.\n            // This is exclusively for simplicity:\n            // this algorithm can be implemented with matrices of different sizes.\n\n            var r = Math.max(r1, r2);\n            var c = Math.max(c1, c2);\n            x = embed(x, r, c);\n            y = embed(y, r, c);\n\n            // Our recursive multiplication function.\n            function blockMult(a, b, rows, cols) {\n                // For small matrices, resort to naive multiplication.\n                if (rows <= 512 || cols <= 512) {\n                    return a.mmul(b); // a is equivalent to this\n                }\n\n                // Apply dynamic padding.\n                if ((rows % 2 === 1) && (cols % 2 === 1)) {\n                    a = embed(a, rows + 1, cols + 1);\n                    b = embed(b, rows + 1, cols + 1);\n                } else if (rows % 2 === 1) {\n                    a = embed(a, rows + 1, cols);\n                    b = embed(b, rows + 1, cols);\n                } else if (cols % 2 === 1) {\n                    a = embed(a, rows, cols + 1);\n                    b = embed(b, rows, cols + 1);\n                }\n\n                var halfRows = parseInt(a.rows / 2);\n                var halfCols = parseInt(a.columns / 2);\n                // Subdivide input matrices.\n                var a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n                var b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n\n                var a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\n                var b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\n\n                var a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\n                var b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\n\n                var a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\n                var b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\n\n                // Compute intermediate values.\n                var m1 = blockMult(Matrix.add(a11, a22), Matrix.add(b11, b22), halfRows, halfCols);\n                var m2 = blockMult(Matrix.add(a21, a22), b11, halfRows, halfCols);\n                var m3 = blockMult(a11, Matrix.sub(b12, b22), halfRows, halfCols);\n                var m4 = blockMult(a22, Matrix.sub(b21, b11), halfRows, halfCols);\n                var m5 = blockMult(Matrix.add(a11, a12), b22, halfRows, halfCols);\n                var m6 = blockMult(Matrix.sub(a21, a11), Matrix.add(b11, b12), halfRows, halfCols);\n                var m7 = blockMult(Matrix.sub(a12, a22), Matrix.add(b21, b22), halfRows, halfCols);\n\n                // Combine intermediate values into the output.\n                var c11 = Matrix.add(m1, m4);\n                c11.sub(m5);\n                c11.add(m7);\n                var c12 = Matrix.add(m3, m5);\n                var c21 = Matrix.add(m2, m4);\n                var c22 = Matrix.sub(m1, m2);\n                c22.add(m3);\n                c22.add(m6);\n\n                //Crop output to the desired size (undo dynamic padding).\n                var resultat = Matrix.zeros(2 * c11.rows, 2 * c11.columns);\n                resultat = resultat.setSubMatrix(c11, 0, 0);\n                resultat = resultat.setSubMatrix(c12, c11.rows, 0);\n                resultat = resultat.setSubMatrix(c21, 0, c11.columns);\n                resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\n                return resultat.subMatrix(0, rows - 1, 0, cols - 1);\n            }\n            return blockMult(x, y, r, c);\n        }\n\n        /**\n         * Returns a row-by-row scaled matrix\n         * @param {number} [min=0] - Minimum scaled value\n         * @param {number} [max=1] - Maximum scaled value\n         * @return {Matrix} - The scaled matrix\n         */\n        scaleRows(min, max) {\n            min = min === undefined ? 0 : min;\n            max = max === undefined ? 1 : max;\n            if (min >= max) {\n                throw new RangeError('min should be strictly smaller than max');\n            }\n            var newMatrix = this.constructor.empty(this.rows, this.columns);\n            for (var i = 0; i < this.rows; i++) {\n                var scaled = arrayUtils.scale(this.getRow(i), {min, max});\n                newMatrix.setRow(i, scaled);\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns a new column-by-column scaled matrix\n         * @param {number} [min=0] - Minimum scaled value\n         * @param {number} [max=1] - Maximum scaled value\n         * @return {Matrix} - The new scaled matrix\n         * @example\n         * var matrix = new Matrix([[1,2],[-1,0]]);\n         * var scaledMatrix = matrix.scaleColumns(); // [[1,1],[0,0]]\n         */\n        scaleColumns(min, max) {\n            min = min === undefined ? 0 : min;\n            max = max === undefined ? 1 : max;\n            if (min >= max) {\n                throw new RangeError('min should be strictly smaller than max');\n            }\n            var newMatrix = this.constructor.empty(this.rows, this.columns);\n            for (var i = 0; i < this.columns; i++) {\n                var scaled = arrayUtils.scale(this.getColumn(i), {\n                    min: min,\n                    max: max\n                });\n                newMatrix.setColumn(i, scaled);\n            }\n            return newMatrix;\n        }\n\n\n        /**\n         * Returns the Kronecker product (also known as tensor product) between this and other\n         * See https://en.wikipedia.org/wiki/Kronecker_product\n         * @param {Matrix} other\n         * @return {Matrix}\n         */\n        kroneckerProduct(other) {\n            other = this.constructor.checkMatrix(other);\n\n            var m = this.rows;\n            var n = this.columns;\n            var p = other.rows;\n            var q = other.columns;\n\n            var result = new this.constructor[Symbol.species](m * p, n * q);\n            for (var i = 0; i < m; i++) {\n                for (var j = 0; j < n; j++) {\n                    for (var k = 0; k < p; k++) {\n                        for (var l = 0; l < q; l++) {\n                            result[p * i + k][q * j + l] = this.get(i, j) * other.get(k, l);\n                        }\n                    }\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Transposes the matrix and returns a new one containing the result\n         * @return {Matrix}\n         */\n        transpose() {\n            var result = new this.constructor[Symbol.species](this.columns, this.rows);\n            for (var i = 0; i < this.rows; i++) {\n                for (var j = 0; j < this.columns; j++) {\n                    result.set(j, i, this.get(i, j));\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Sorts the rows (in place)\n         * @param {function} compareFunction - usual Array.prototype.sort comparison function\n         * @return {Matrix} this\n         */\n        sortRows(compareFunction) {\n            if (compareFunction === undefined) compareFunction = compareNumbers;\n            for (var i = 0; i < this.rows; i++) {\n                this.setRow(i, this.getRow(i).sort(compareFunction));\n            }\n            return this;\n        }\n\n        /**\n         * Sorts the columns (in place)\n         * @param {function} compareFunction - usual Array.prototype.sort comparison function\n         * @return {Matrix} this\n         */\n        sortColumns(compareFunction) {\n            if (compareFunction === undefined) compareFunction = compareNumbers;\n            for (var i = 0; i < this.columns; i++) {\n                this.setColumn(i, this.getColumn(i).sort(compareFunction));\n            }\n            return this;\n        }\n\n        /**\n         * Returns a subset of the matrix\n         * @param {number} startRow - First row index\n         * @param {number} endRow - Last row index\n         * @param {number} startColumn - First column index\n         * @param {number} endColumn - Last column index\n         * @return {Matrix}\n         */\n        subMatrix(startRow, endRow, startColumn, endColumn) {\n            util.checkRange(this, startRow, endRow, startColumn, endColumn);\n            var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, endColumn - startColumn + 1);\n            for (var i = startRow; i <= endRow; i++) {\n                for (var j = startColumn; j <= endColumn; j++) {\n                    newMatrix[i - startRow][j - startColumn] = this.get(i, j);\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns a subset of the matrix based on an array of row indices\n         * @param {Array} indices - Array containing the row indices\n         * @param {number} [startColumn = 0] - First column index\n         * @param {number} [endColumn = this.columns-1] - Last column index\n         * @return {Matrix}\n         */\n        subMatrixRow(indices, startColumn, endColumn) {\n            if (startColumn === undefined) startColumn = 0;\n            if (endColumn === undefined) endColumn = this.columns - 1;\n            if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {\n                throw new RangeError('Argument out of range');\n            }\n\n            var newMatrix = new this.constructor[Symbol.species](indices.length, endColumn - startColumn + 1);\n            for (var i = 0; i < indices.length; i++) {\n                for (var j = startColumn; j <= endColumn; j++) {\n                    if (indices[i] < 0 || indices[i] >= this.rows) {\n                        throw new RangeError('Row index out of range: ' + indices[i]);\n                    }\n                    newMatrix.set(i, j - startColumn, this.get(indices[i], j));\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns a subset of the matrix based on an array of column indices\n         * @param {Array} indices - Array containing the column indices\n         * @param {number} [startRow = 0] - First row index\n         * @param {number} [endRow = this.rows-1] - Last row index\n         * @return {Matrix}\n         */\n        subMatrixColumn(indices, startRow, endRow) {\n            if (startRow === undefined) startRow = 0;\n            if (endRow === undefined) endRow = this.rows - 1;\n            if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {\n                throw new RangeError('Argument out of range');\n            }\n\n            var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, indices.length);\n            for (var i = 0; i < indices.length; i++) {\n                for (var j = startRow; j <= endRow; j++) {\n                    if (indices[i] < 0 || indices[i] >= this.columns) {\n                        throw new RangeError('Column index out of range: ' + indices[i]);\n                    }\n                    newMatrix.set(j - startRow, i, this.get(j, indices[i]));\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Set a part of the matrix to the given sub-matrix\n         * @param {Matrix|Array< Array >} matrix - The source matrix from which to extract values.\n         * @param {number} startRow - The index of the first row to set\n         * @param {number} startColumn - The index of the first column to set\n         * @return {Matrix}\n         */\n        setSubMatrix(matrix, startRow, startColumn) {\n            matrix = this.constructor.checkMatrix(matrix);\n            var endRow = startRow + matrix.rows - 1;\n            var endColumn = startColumn + matrix.columns - 1;\n            util.checkRange(this, startRow, endRow, startColumn, endColumn);\n            for (var i = 0; i < matrix.rows; i++) {\n                for (var j = 0; j < matrix.columns; j++) {\n                    this[startRow + i][startColumn + j] = matrix.get(i, j);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Return a new matrix based on a selection of rows and columns\n         * @param {Array<number>} rowIndices - The row indices to select. Order matters and an index can be more than once.\n         * @param {Array<number>} columnIndices - The column indices to select. Order matters and an index can be use more than once.\n         * @return {Matrix} The new matrix\n         */\n        selection(rowIndices, columnIndices) {\n            var indices = util.checkIndices(this, rowIndices, columnIndices);\n            var newMatrix = new this.constructor[Symbol.species](rowIndices.length, columnIndices.length);\n            for (var i = 0; i < indices.row.length; i++) {\n                var rowIndex = indices.row[i];\n                for (var j = 0; j < indices.column.length; j++) {\n                    var columnIndex = indices.column[j];\n                    newMatrix[i][j] = this.get(rowIndex, columnIndex);\n                }\n            }\n            return newMatrix;\n        }\n\n        /**\n         * Returns the trace of the matrix (sum of the diagonal elements)\n         * @return {number}\n         */\n        trace() {\n            var min = Math.min(this.rows, this.columns);\n            var trace = 0;\n            for (var i = 0; i < min; i++) {\n                trace += this.get(i, i);\n            }\n            return trace;\n        }\n\n        /*\n         Matrix views\n         */\n\n        /**\n         * Returns a view of the transposition of the matrix\n         * @return {MatrixTransposeView}\n         */\n        transposeView() {\n            return new MatrixTransposeView(this);\n        }\n\n        /**\n         * Returns a view of the row vector with the given index\n         * @param {number} row - row index of the vector\n         * @return {MatrixRowView}\n         */\n        rowView(row) {\n            util.checkRowIndex(this, row);\n            return new MatrixRowView(this, row);\n        }\n\n        /**\n         * Returns a view of the column vector with the given index\n         * @param {number} column - column index of the vector\n         * @return {MatrixColumnView}\n         */\n        columnView(column) {\n            util.checkColumnIndex(this, column);\n            return new MatrixColumnView(this, column);\n        }\n\n        /**\n         * Returns a view of the matrix flipped in the row axis\n         * @return {MatrixFlipRowView}\n         */\n        flipRowView() {\n            return new MatrixFlipRowView(this);\n        }\n\n        /**\n         * Returns a view of the matrix flipped in the column axis\n         * @return {MatrixFlipColumnView}\n         */\n        flipColumnView() {\n            return new MatrixFlipColumnView(this);\n        }\n\n        /**\n         * Returns a view of a submatrix giving the index boundaries\n         * @param {number} startRow - first row index of the submatrix\n         * @param {number} endRow - last row index of the submatrix\n         * @param {number} startColumn - first column index of the submatrix\n         * @param {number} endColumn - last column index of the submatrix\n         * @return {MatrixSubView}\n         */\n        subMatrixView(startRow, endRow, startColumn, endColumn) {\n            return new MatrixSubView(this, startRow, endRow, startColumn, endColumn);\n        }\n\n        /**\n         * Returns a view of the cross of the row indices and the column indices\n         * @example\n         * // resulting vector is [[2], [2]]\n         * var matrix = new Matrix([[1,2,3], [4,5,6]]).selectionView([0, 0], [1])\n         * @param {Array<number>} rowIndices\n         * @param {Array<number>} columnIndices\n         * @return {MatrixSelectionView}\n         */\n        selectionView(rowIndices, columnIndices) {\n            return new MatrixSelectionView(this, rowIndices, columnIndices);\n        }\n\n\n        /**\n        * Calculates and returns the determinant of a matrix as a Number\n        * @example\n        *   new Matrix([[1,2,3], [4,5,6]]).det()\n        * @return {number}\n        */\n        det() {\n            if (this.isSquare()) {\n                var a, b, c, d;\n                if (this.columns === 2) {\n                    // 2 x 2 matrix\n                    a = this.get(0, 0);\n                    b = this.get(0, 1);\n                    c = this.get(1, 0);\n                    d = this.get(1, 1);\n\n                    return a * d - (b * c);\n                } else if (this.columns === 3) {\n                    // 3 x 3 matrix\n                    var subMatrix0, subMatrix1, subMatrix2;\n                    subMatrix0 = this.selectionView([1, 2], [1, 2]);\n                    subMatrix1 = this.selectionView([1, 2], [0, 2]);\n                    subMatrix2 = this.selectionView([1, 2], [0, 1]);\n                    a = this.get(0, 0);\n                    b = this.get(0, 1);\n                    c = this.get(0, 2);\n\n                    return a * subMatrix0.det() - b * subMatrix1.det() + c * subMatrix2.det();\n                } else {\n                    // general purpose determinant using the LU decomposition\n                    return new LuDecomposition(this).determinant;\n                }\n\n            } else {\n                throw Error('Determinant can only be calculated for a square matrix.');\n            }\n        }\n\n        /**\n         * Returns inverse of a matrix if it exists or the pseudoinverse\n         * @param {number} threshold - threshold for taking inverse of singular values (default = 1e-15)\n         * @return {Matrix} the (pseudo)inverted matrix.\n         */\n        pseudoInverse(threshold) {\n            if (threshold === undefined) threshold = Number.EPSILON;\n            var svdSolution = new SvDecomposition(this, {autoTranspose: true});\n\n            var U = svdSolution.leftSingularVectors;\n            var V = svdSolution.rightSingularVectors;\n            var s = svdSolution.diagonal;\n\n            for (var i = 0; i < s.length; i++) {\n                if (Math.abs(s[i]) > threshold) {\n                    s[i] = 1.0 / s[i];\n                } else {\n                    s[i] = 0.0;\n                }\n            }\n\n            // convert list to diagonal\n            s = this.constructor[Symbol.species].diag(s);\n            return V.mmul(s.mmul(U.transposeView()));\n        }\n    }\n\n    Matrix.prototype.klass = 'Matrix';\n\n    /**\n     * @private\n     * Check that two matrices have the same dimensions\n     * @param {Matrix} matrix\n     * @param {Matrix} otherMatrix\n     */\n    function checkDimensions(matrix, otherMatrix) { // eslint-disable-line no-unused-vars\n        if (matrix.rows !== otherMatrix.rows ||\n            matrix.columns !== otherMatrix.columns) {\n            throw new RangeError('Matrices dimensions must be equal');\n        }\n    }\n\n    function compareNumbers(a, b) {\n        return a - b;\n    }\n\n    /*\n     Synonyms\n     */\n\n    Matrix.random = Matrix.rand;\n    Matrix.diagonal = Matrix.diag;\n    Matrix.prototype.diagonal = Matrix.prototype.diag;\n    Matrix.identity = Matrix.eye;\n    Matrix.prototype.negate = Matrix.prototype.neg;\n    Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;\n    Matrix.prototype.determinant = Matrix.prototype.det;\n\n    /*\n     Add dynamically instance and static methods for mathematical operations\n     */\n\n    var inplaceOperator = `\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n`;\n\n    var inplaceOperatorScalar = `\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% value);\n        }\n    }\n    return this;\n})\n`;\n\n    var inplaceOperatorMatrix = `\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    checkDimensions(this, matrix);\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));\n        }\n    }\n    return this;\n})\n`;\n\n    var staticOperator = `\n(function %name%(matrix, value) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(value);\n})\n`;\n\n    var inplaceMethod = `\n(function %name%() {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j)));\n        }\n    }\n    return this;\n})\n`;\n\n    var staticMethod = `\n(function %name%(matrix) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%();\n})\n`;\n\n    var inplaceMethodWithArgs = `\n(function %name%(%args%) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), %args%));\n        }\n    }\n    return this;\n})\n`;\n\n    var staticMethodWithArgs = `\n(function %name%(matrix, %args%) {\n    var newMatrix = new this[Symbol.species](matrix);\n    return newMatrix.%name%(%args%);\n})\n`;\n\n\n    var inplaceMethodWithOneArgScalar = `\n(function %name%S(value) {\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), value));\n        }\n    }\n    return this;\n})\n`;\n    var inplaceMethodWithOneArgMatrix = `\n(function %name%M(matrix) {\n    matrix = this.constructor.checkMatrix(matrix);\n    checkDimensions(this, matrix);\n    for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.columns; j++) {\n            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));\n        }\n    }\n    return this;\n})\n`;\n\n    var inplaceMethodWithOneArg = `\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n`;\n\n    var staticMethodWithOneArg = staticMethodWithArgs;\n\n    var operators = [\n        // Arithmetic operators\n        ['+', 'add'],\n        ['-', 'sub', 'subtract'],\n        ['*', 'mul', 'multiply'],\n        ['/', 'div', 'divide'],\n        ['%', 'mod', 'modulus'],\n        // Bitwise operators\n        ['&', 'and'],\n        ['|', 'or'],\n        ['^', 'xor'],\n        ['<<', 'leftShift'],\n        ['>>', 'signPropagatingRightShift'],\n        ['>>>', 'rightShift', 'zeroFillRightShift']\n    ];\n\n    var i;\n\n    for (var operator of operators) {\n        var inplaceOp = eval(fillTemplateFunction(inplaceOperator, {name: operator[1], op: operator[0]}));\n        var inplaceOpS = eval(fillTemplateFunction(inplaceOperatorScalar, {name: operator[1] + 'S', op: operator[0]}));\n        var inplaceOpM = eval(fillTemplateFunction(inplaceOperatorMatrix, {name: operator[1] + 'M', op: operator[0]}));\n        var staticOp = eval(fillTemplateFunction(staticOperator, {name: operator[1]}));\n        for (i = 1; i < operator.length; i++) {\n            Matrix.prototype[operator[i]] = inplaceOp;\n            Matrix.prototype[operator[i] + 'S'] = inplaceOpS;\n            Matrix.prototype[operator[i] + 'M'] = inplaceOpM;\n            Matrix[operator[i]] = staticOp;\n        }\n    }\n\n    var methods = [\n        ['~', 'not']\n    ];\n\n    [\n        'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil',\n        'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p',\n        'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'\n    ].forEach(function (mathMethod) {\n        methods.push(['Math.' + mathMethod, mathMethod]);\n    });\n\n    for (var method of methods) {\n        var inplaceMeth = eval(fillTemplateFunction(inplaceMethod, {name: method[1], method: method[0]}));\n        var staticMeth = eval(fillTemplateFunction(staticMethod, {name: method[1]}));\n        for (i = 1; i < method.length; i++) {\n            Matrix.prototype[method[i]] = inplaceMeth;\n            Matrix[method[i]] = staticMeth;\n        }\n    }\n\n    var methodsWithArgs = [\n        ['Math.pow', 1, 'pow']\n    ];\n\n    for (var methodWithArg of methodsWithArgs) {\n        var args = 'arg0';\n        for (i = 1; i < methodWithArg[1]; i++) {\n            args += `, arg${i}`;\n        }\n        if (methodWithArg[1] !== 1) {\n            var inplaceMethWithArgs = eval(fillTemplateFunction(inplaceMethodWithArgs, {\n                name: methodWithArg[2],\n                method: methodWithArg[0],\n                args: args\n            }));\n            var staticMethWithArgs = eval(fillTemplateFunction(staticMethodWithArgs, {name: methodWithArg[2], args: args}));\n            for (i = 2; i < methodWithArg.length; i++) {\n                Matrix.prototype[methodWithArg[i]] = inplaceMethWithArgs;\n                Matrix[methodWithArg[i]] = staticMethWithArgs;\n            }\n        } else {\n            var tmplVar = {\n                name: methodWithArg[2],\n                args: args,\n                method: methodWithArg[0]\n            };\n            var inplaceMethod2 = eval(fillTemplateFunction(inplaceMethodWithOneArg, tmplVar));\n            var inplaceMethodS = eval(fillTemplateFunction(inplaceMethodWithOneArgScalar, tmplVar));\n            var inplaceMethodM = eval(fillTemplateFunction(inplaceMethodWithOneArgMatrix, tmplVar));\n            var staticMethod2 = eval(fillTemplateFunction(staticMethodWithOneArg, tmplVar));\n            for (i = 2; i < methodWithArg.length; i++) {\n                Matrix.prototype[methodWithArg[i]] = inplaceMethod2;\n                Matrix.prototype[methodWithArg[i] + 'M'] = inplaceMethodM;\n                Matrix.prototype[methodWithArg[i] + 'S'] = inplaceMethodS;\n                Matrix[methodWithArg[i]] = staticMethod2;\n            }\n        }\n    }\n\n    function fillTemplateFunction(template, values) {\n        for (var value in values) {\n            template = template.replace(new RegExp('%' + value + '%', 'g'), values[value]);\n        }\n        return template;\n    }\n\n    return Matrix;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/abstractMatrix.js\n// module id = 9\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix');\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\nfunction LuDecomposition(matrix) {\n    if (!(this instanceof LuDecomposition)) {\n        return new LuDecomposition(matrix);\n    }\n\n    matrix = Matrix.Matrix.checkMatrix(matrix);\n\n    var lu = matrix.clone(),\n        rows = lu.rows,\n        columns = lu.columns,\n        pivotVector = new Array(rows),\n        pivotSign = 1,\n        i, j, k, p, s, t, v,\n        LUrowi, LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n        pivotVector[i] = i;\n    }\n\n    LUcolj = new Array(rows);\n\n    for (j = 0; j < columns; j++) {\n\n        for (i = 0; i < rows; i++) {\n            LUcolj[i] = lu[i][j];\n        }\n\n        for (i = 0; i < rows; i++) {\n            LUrowi = lu[i];\n            kmax = Math.min(i, j);\n            s = 0;\n            for (k = 0; k < kmax; k++) {\n                s += LUrowi[k] * LUcolj[k];\n            }\n            LUrowi[j] = LUcolj[i] -= s;\n        }\n\n        p = j;\n        for (i = j + 1; i < rows; i++) {\n            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n                p = i;\n            }\n        }\n\n        if (p !== j) {\n            for (k = 0; k < columns; k++) {\n                t = lu[p][k];\n                lu[p][k] = lu[j][k];\n                lu[j][k] = t;\n            }\n\n            v = pivotVector[p];\n            pivotVector[p] = pivotVector[j];\n            pivotVector[j] = v;\n\n            pivotSign = -pivotSign;\n        }\n\n        if (j < rows && lu[j][j] !== 0) {\n            for (i = j + 1; i < rows; i++) {\n                lu[i][j] /= lu[j][j];\n            }\n        }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n}\n\nLuDecomposition.prototype = {\n    isSingular: function () {\n        var data = this.LU,\n            col = data.columns;\n        for (var j = 0; j < col; j++) {\n            if (data[j][j] === 0) {\n                return true;\n            }\n        }\n        return false;\n    },\n    get determinant() {\n        var data = this.LU;\n        if (!data.isSquare()) {\n            throw new Error('Matrix must be square');\n        }\n        var determinant = this.pivotSign, col = data.columns;\n        for (var j = 0; j < col; j++) {\n            determinant *= data[j][j];\n        }\n        return determinant;\n    },\n    get lowerTriangularMatrix() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix.Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i > j) {\n                    X[i][j] = data[i][j];\n                } else if (i === j) {\n                    X[i][j] = 1;\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get upperTriangularMatrix() {\n        var data = this.LU,\n            rows = data.rows,\n            columns = data.columns,\n            X = new Matrix.Matrix(rows, columns);\n        for (var i = 0; i < rows; i++) {\n            for (var j = 0; j < columns; j++) {\n                if (i <= j) {\n                    X[i][j] = data[i][j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get pivotPermutationVector() {\n        return this.pivotVector.slice();\n    },\n    solve: function (value) {\n        value = Matrix.Matrix.checkMatrix(value);\n\n        var lu = this.LU,\n            rows = lu.rows;\n\n        if (rows !== value.rows) {\n            throw new Error('Invalid matrix dimensions');\n        }\n        if (this.isSingular()) {\n            throw new Error('LU matrix is singular');\n        }\n\n        var count = value.columns;\n        var X = value.subMatrixRow(this.pivotVector, 0, count - 1);\n        var columns = lu.columns;\n        var i, j, k;\n\n        for (k = 0; k < columns; k++) {\n            for (i = k + 1; i < columns; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        for (k = columns - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= lu[k][k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * lu[i][k];\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = LuDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/lu.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix');\nvar util = require('./util');\nvar hypotenuse = util.hypotenuse;\nvar getFilled2DArray = util.getFilled2DArray;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/SingularValueDecomposition.cs\nfunction SingularValueDecomposition(value, options) {\n    if (!(this instanceof SingularValueDecomposition)) {\n        return new SingularValueDecomposition(value, options);\n    }\n    value = Matrix.Matrix.checkMatrix(value);\n\n    options = options || {};\n\n    var m = value.rows,\n        n = value.columns,\n        nu = Math.min(m, n);\n\n    var wantu = true, wantv = true;\n    if (options.computeLeftSingularVectors === false) wantu = false;\n    if (options.computeRightSingularVectors === false) wantv = false;\n    var autoTranspose = options.autoTranspose === true;\n\n    var swapped = false;\n    var a;\n    if (m < n) {\n        if (!autoTranspose) {\n            a = value.clone();\n            // eslint-disable-next-line no-console\n            console.warn('Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose');\n        } else {\n            a = value.transpose();\n            m = a.rows;\n            n = a.columns;\n            swapped = true;\n            var aux = wantu;\n            wantu = wantv;\n            wantv = aux;\n        }\n    } else {\n        a = value.clone();\n    }\n\n    var s = new Array(Math.min(m + 1, n)),\n        U = getFilled2DArray(m, nu, 0),\n        V = getFilled2DArray(n, n, 0),\n        e = new Array(n),\n        work = new Array(m);\n\n    var nct = Math.min(m - 1, n);\n    var nrt = Math.max(0, Math.min(n - 2, m));\n\n    var i, j, k, p, t, ks, f, cs, sn, max, kase,\n        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;\n\n    for (k = 0, max = Math.max(nct, nrt); k < max; k++) {\n        if (k < nct) {\n            s[k] = 0;\n            for (i = k; i < m; i++) {\n                s[k] = hypotenuse(s[k], a[i][k]);\n            }\n            if (s[k] !== 0) {\n                if (a[k][k] < 0) {\n                    s[k] = -s[k];\n                }\n                for (i = k; i < m; i++) {\n                    a[i][k] /= s[k];\n                }\n                a[k][k] += 1;\n            }\n            s[k] = -s[k];\n        }\n\n        for (j = k + 1; j < n; j++) {\n            if ((k < nct) && (s[k] !== 0)) {\n                t = 0;\n                for (i = k; i < m; i++) {\n                    t += a[i][k] * a[i][j];\n                }\n                t = -t / a[k][k];\n                for (i = k; i < m; i++) {\n                    a[i][j] += t * a[i][k];\n                }\n            }\n            e[j] = a[k][j];\n        }\n\n        if (wantu && (k < nct)) {\n            for (i = k; i < m; i++) {\n                U[i][k] = a[i][k];\n            }\n        }\n\n        if (k < nrt) {\n            e[k] = 0;\n            for (i = k + 1; i < n; i++) {\n                e[k] = hypotenuse(e[k], e[i]);\n            }\n            if (e[k] !== 0) {\n                if (e[k + 1] < 0) {\n                    e[k] = 0 - e[k];\n                }\n                for (i = k + 1; i < n; i++) {\n                    e[i] /= e[k];\n                }\n                e[k + 1] += 1;\n            }\n            e[k] = -e[k];\n            if ((k + 1 < m) && (e[k] !== 0)) {\n                for (i = k + 1; i < m; i++) {\n                    work[i] = 0;\n                }\n                for (j = k + 1; j < n; j++) {\n                    for (i = k + 1; i < m; i++) {\n                        work[i] += e[j] * a[i][j];\n                    }\n                }\n                for (j = k + 1; j < n; j++) {\n                    t = -e[j] / e[k + 1];\n                    for (i = k + 1; i < m; i++) {\n                        a[i][j] += t * work[i];\n                    }\n                }\n            }\n            if (wantv) {\n                for (i = k + 1; i < n; i++) {\n                    V[i][k] = e[i];\n                }\n            }\n        }\n    }\n\n    p = Math.min(n, m + 1);\n    if (nct < n) {\n        s[nct] = a[nct][nct];\n    }\n    if (m < p) {\n        s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n        e[nrt] = a[nrt][p - 1];\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n        for (j = nct; j < nu; j++) {\n            for (i = 0; i < m; i++) {\n                U[i][j] = 0;\n            }\n            U[j][j] = 1;\n        }\n        for (k = nct - 1; k >= 0; k--) {\n            if (s[k] !== 0) {\n                for (j = k + 1; j < nu; j++) {\n                    t = 0;\n                    for (i = k; i < m; i++) {\n                        t += U[i][k] * U[i][j];\n                    }\n                    t = -t / U[k][k];\n                    for (i = k; i < m; i++) {\n                        U[i][j] += t * U[i][k];\n                    }\n                }\n                for (i = k; i < m; i++) {\n                    U[i][k] = -U[i][k];\n                }\n                U[k][k] = 1 + U[k][k];\n                for (i = 0; i < k - 1; i++) {\n                    U[i][k] = 0;\n                }\n            } else {\n                for (i = 0; i < m; i++) {\n                    U[i][k] = 0;\n                }\n                U[k][k] = 1;\n            }\n        }\n    }\n\n    if (wantv) {\n        for (k = n - 1; k >= 0; k--) {\n            if ((k < nrt) && (e[k] !== 0)) {\n                for (j = k + 1; j < n; j++) {\n                    t = 0;\n                    for (i = k + 1; i < n; i++) {\n                        t += V[i][k] * V[i][j];\n                    }\n                    t = -t / V[k + 1][k];\n                    for (i = k + 1; i < n; i++) {\n                        V[i][j] += t * V[i][k];\n                    }\n                }\n            }\n            for (i = 0; i < n; i++) {\n                V[i][k] = 0;\n            }\n            V[k][k] = 1;\n        }\n    }\n\n    var pp = p - 1,\n        iter = 0,\n        eps = Math.pow(2, -52);\n    while (p > 0) {\n        for (k = p - 2; k >= -1; k--) {\n            if (k === -1) {\n                break;\n            }\n            if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {\n                e[k] = 0;\n                break;\n            }\n        }\n        if (k === p - 2) {\n            kase = 4;\n        } else {\n            for (ks = p - 1; ks >= k; ks--) {\n                if (ks === k) {\n                    break;\n                }\n                t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n                if (Math.abs(s[ks]) <= eps * t) {\n                    s[ks] = 0;\n                    break;\n                }\n            }\n            if (ks === k) {\n                kase = 3;\n            } else if (ks === p - 1) {\n                kase = 1;\n            } else {\n                kase = 2;\n                k = ks;\n            }\n        }\n\n        k++;\n\n        switch (kase) {\n            case 1: {\n                f = e[p - 2];\n                e[p - 2] = 0;\n                for (j = p - 2; j >= k; j--) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    if (j !== k) {\n                        f = -sn * e[j - 1];\n                        e[j - 1] = cs * e[j - 1];\n                    }\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][p - 1];\n                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n                            V[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 2 : {\n                f = e[k - 1];\n                e[k - 1] = 0;\n                for (j = k; j < p; j++) {\n                    t = hypotenuse(s[j], f);\n                    cs = s[j] / t;\n                    sn = f / t;\n                    s[j] = t;\n                    f = -sn * e[j];\n                    e[j] = cs * e[j];\n                    if (wantu) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][k - 1];\n                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                break;\n            }\n            case 3 : {\n                scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])), Math.abs(s[k])), Math.abs(e[k]));\n                sp = s[p - 1] / scale;\n                spm1 = s[p - 2] / scale;\n                epm1 = e[p - 2] / scale;\n                sk = s[k] / scale;\n                ek = e[k] / scale;\n                b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n                c = (sp * epm1) * (sp * epm1);\n                shift = 0;\n                if ((b !== 0) || (c !== 0)) {\n                    shift = Math.sqrt(b * b + c);\n                    if (b < 0) {\n                        shift = -shift;\n                    }\n                    shift = c / (b + shift);\n                }\n                f = (sk + sp) * (sk - sp) + shift;\n                g = sk * ek;\n                for (j = k; j < p - 1; j++) {\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    if (j !== k) {\n                        e[j - 1] = t;\n                    }\n                    f = cs * s[j] + sn * e[j];\n                    e[j] = cs * e[j] - sn * s[j];\n                    g = sn * s[j + 1];\n                    s[j + 1] = cs * s[j + 1];\n                    if (wantv) {\n                        for (i = 0; i < n; i++) {\n                            t = cs * V[i][j] + sn * V[i][j + 1];\n                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n                            V[i][j] = t;\n                        }\n                    }\n                    t = hypotenuse(f, g);\n                    cs = f / t;\n                    sn = g / t;\n                    s[j] = t;\n                    f = cs * e[j] + sn * s[j + 1];\n                    s[j + 1] = -sn * e[j] + cs * s[j + 1];\n                    g = sn * e[j + 1];\n                    e[j + 1] = cs * e[j + 1];\n                    if (wantu && (j < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = cs * U[i][j] + sn * U[i][j + 1];\n                            U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                            U[i][j] = t;\n                        }\n                    }\n                }\n                e[p - 2] = f;\n                iter = iter + 1;\n                break;\n            }\n            case 4: {\n                if (s[k] <= 0) {\n                    s[k] = (s[k] < 0 ? -s[k] : 0);\n                    if (wantv) {\n                        for (i = 0; i <= pp; i++) {\n                            V[i][k] = -V[i][k];\n                        }\n                    }\n                }\n                while (k < pp) {\n                    if (s[k] >= s[k + 1]) {\n                        break;\n                    }\n                    t = s[k];\n                    s[k] = s[k + 1];\n                    s[k + 1] = t;\n                    if (wantv && (k < n - 1)) {\n                        for (i = 0; i < n; i++) {\n                            t = V[i][k + 1];\n                            V[i][k + 1] = V[i][k];\n                            V[i][k] = t;\n                        }\n                    }\n                    if (wantu && (k < m - 1)) {\n                        for (i = 0; i < m; i++) {\n                            t = U[i][k + 1];\n                            U[i][k + 1] = U[i][k];\n                            U[i][k] = t;\n                        }\n                    }\n                    k++;\n                }\n                iter = 0;\n                p--;\n                break;\n            }\n            // no default\n        }\n    }\n\n    if (swapped) {\n        var tmp = V;\n        V = U;\n        U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n}\n\nSingularValueDecomposition.prototype = {\n    get condition() {\n        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n    },\n    get norm2() {\n        return this.s[0];\n    },\n    get rank() {\n        var eps = Math.pow(2, -52),\n            tol = Math.max(this.m, this.n) * this.s[0] * eps,\n            r = 0,\n            s = this.s;\n        for (var i = 0, ii = s.length; i < ii; i++) {\n            if (s[i] > tol) {\n                r++;\n            }\n        }\n        return r;\n    },\n    get diagonal() {\n        return this.s;\n    },\n    // https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\n    get threshold() {\n        return (Math.pow(2, -52) / 2) * Math.max(this.m, this.n) * this.s[0];\n    },\n    get leftSingularVectors() {\n        if (!Matrix.Matrix.isMatrix(this.U)) {\n            this.U = new Matrix.Matrix(this.U);\n        }\n        return this.U;\n    },\n    get rightSingularVectors() {\n        if (!Matrix.Matrix.isMatrix(this.V)) {\n            this.V = new Matrix.Matrix(this.V);\n        }\n        return this.V;\n    },\n    get diagonalMatrix() {\n        return Matrix.Matrix.diag(this.s);\n    },\n    solve: function (value) {\n\n        var Y = value,\n            e = this.threshold,\n            scols = this.s.length,\n            Ls = Matrix.Matrix.zeros(scols, scols),\n            i;\n\n        for (i = 0; i < scols; i++) {\n            if (Math.abs(this.s[i]) <= e) {\n                Ls[i][i] = 0;\n            } else {\n                Ls[i][i] = 1 / this.s[i];\n            }\n        }\n\n        var U = this.U;\n        var V = this.rightSingularVectors;\n\n        var VL = V.mmul(Ls),\n            vrows = V.rows,\n            urows = U.length,\n            VLU = Matrix.Matrix.zeros(vrows, urows),\n            j, k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < scols; k++) {\n                    sum += VL[i][k] * U[j][k];\n                }\n                VLU[i][j] = sum;\n            }\n        }\n\n        return VLU.mmul(Y);\n    },\n    solveForDiagonal: function (value) {\n        return this.solve(Matrix.Matrix.diag(value));\n    },\n    inverse: function () {\n        var V = this.V;\n        var e = this.threshold,\n            vrows = V.length,\n            vcols = V[0].length,\n            X = new Matrix.Matrix(vrows, this.s.length),\n            i, j;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < vcols; j++) {\n                if (Math.abs(this.s[j]) > e) {\n                    X[i][j] = V[i][j] / this.s[j];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n\n        var U = this.U;\n\n        var urows = U.length,\n            ucols = U[0].length,\n            Y = new Matrix.Matrix(vrows, urows),\n            k, sum;\n\n        for (i = 0; i < vrows; i++) {\n            for (j = 0; j < urows; j++) {\n                sum = 0;\n                for (k = 0; k < ucols; k++) {\n                    sum += X[i][k] * U[j][k];\n                }\n                Y[i][j] = sum;\n            }\n        }\n\n        return Y;\n    }\n};\n\nmodule.exports = SingularValueDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/svd.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nmodule.exports = require('./matrix').Matrix;\nmodule.exports.Decompositions = module.exports.DC = require('./decompositions');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/index.js\n// module id = 12\n// module chunks = 0","'use strict';\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\n/**\n * Computes the sum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.sum = function sum(values) {\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum;\n};\n\n/**\n * Computes the maximum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.max = function max(values) {\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n};\n\n/**\n * Computes the minimum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.min = function min(values) {\n    var min = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n};\n\n/**\n * Computes the min and max of the given values\n * @param {Array} values\n * @returns {{min: number, max: number}}\n */\nexports.minMax = function minMax(values) {\n    var min = values[0];\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n};\n\n/**\n * Computes the arithmetic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.arithmeticMean = function arithmeticMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        sum += values[i];\n    }\n    return sum / l;\n};\n\n/**\n * {@link arithmeticMean}\n */\nexports.mean = exports.arithmeticMean;\n\n/**\n * Computes the geometric mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.geometricMean = function geometricMean(values) {\n    var mul = 1;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        mul *= values[i];\n    }\n    return Math.pow(mul, 1 / l);\n};\n\n/**\n * Computes the mean of the log of the given values\n * If the return value is exponentiated, it gives the same result as the\n * geometric mean.\n * @param {Array} values\n * @returns {number}\n */\nexports.logMean = function logMean(values) {\n    var lnsum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        lnsum += Math.log(values[i]);\n    }\n    return lnsum / l;\n};\n\n/**\n * Computes the weighted grand mean for a list of means and sample sizes\n * @param {Array} means - Mean values for each set of samples\n * @param {Array} samples - Number of original values for each set of samples\n * @returns {number}\n */\nexports.grandMean = function grandMean(means, samples) {\n    var sum = 0;\n    var n = 0;\n    var l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n};\n\n/**\n * Computes the truncated mean of the given values using a given percentage\n * @param {Array} values\n * @param {number} percent - The percentage of values to keep (range: [0,1])\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var k = Math.floor(l * percent);\n    var sum = 0;\n    for (var i = k; i < (l - k); i++) {\n        sum += values[i];\n    }\n    return sum / (l - 2 * k);\n};\n\n/**\n * Computes the harmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.harmonicMean = function harmonicMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] === 0) {\n            throw new RangeError('value at index ' + i + 'is zero');\n        }\n        sum += 1 / values[i];\n    }\n    return l / sum;\n};\n\n/**\n * Computes the contraharmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.contraHarmonicMean = function contraHarmonicMean(values) {\n    var r1 = 0;\n    var r2 = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += values[i] * values[i];\n        r2 += values[i];\n    }\n    if (r2 < 0) {\n        throw new RangeError('sum of values is negative');\n    }\n    return r1 / r2;\n};\n\n/**\n * Computes the median of the given values\n * @param {Array} values\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.median = function median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n};\n\n/**\n * Computes the variance of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.variance = function variance(values, unbiased) {\n    if (unbiased === undefined) unbiased = true;\n    var theMean = exports.mean(values);\n    var theVariance = 0;\n    var l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased) {\n        return theVariance / (l - 1);\n    } else {\n        return theVariance / l;\n    }\n};\n\n/**\n * Computes the standard deviation of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.standardDeviation = function standardDeviation(values, unbiased) {\n    return Math.sqrt(exports.variance(values, unbiased));\n};\n\nexports.standardError = function standardError(values) {\n    return exports.standardDeviation(values) / Math.sqrt(values.length);\n};\n\n/**\n * IEEE Transactions on biomedical engineering, vol. 52, no. 1, january 2005, p. 76-\n * Calculate the standard deviation via the Median of the absolute deviation\n *  The formula for the standard deviation only holds for Gaussian random variables.\n * @returns {{mean: number, stdev: number}}\n */\nexports.robustMeanAndStdev = function robustMeanAndStdev(y) {\n    var mean = 0, stdev = 0;\n    var length = y.length, i = 0;\n    for (i = 0; i < length; i++) {\n        mean += y[i];\n    }\n    mean /= length;\n    var averageDeviations = new Array(length);\n    for (i = 0; i < length; i++)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort(compareNumbers);\n    if (length % 2 === 1) {\n        stdev = averageDeviations[(length - 1) / 2] / 0.6745;\n    } else {\n        stdev = 0.5 * (averageDeviations[length / 2] + averageDeviations[length / 2 - 1]) / 0.6745;\n    }\n\n    return {\n        mean: mean,\n        stdev: stdev\n    };\n};\n\nexports.quartiles = function quartiles(values, alreadySorted) {\n    if (typeof (alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = exports.median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n};\n\nexports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n};\n\nexports.pooledVariance = function pooledVariance(samples, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = exports.variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n};\n\nexports.mode = function mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n};\n\nexports.covariance = function covariance(vector1, vector2, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var mean1 = exports.mean(vector1);\n    var mean2 = exports.mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw 'Vectors do not have the same dimensions';\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n};\n\nexports.skewness = function skewness(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    } else {\n        return g;\n    }\n};\n\nexports.kurtosis = function kurtosis(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    } else {\n        return m4 / (m2 * m2) - 3;\n    }\n};\n\nexports.entropy = function entropy(values, eps) {\n    if (typeof (eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n};\n\nexports.weightedMean = function weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n};\n\nexports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n    return Math.sqrt(exports.weightedVariance(values, weights));\n};\n\nexports.weightedVariance = function weightedVariance(values, weights) {\n    var theMean = exports.weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n};\n\nexports.center = function center(values, inPlace) {\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = [].concat(values);\n\n    var theMean = exports.mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n};\n\nexports.standardize = function standardize(values, standardDev, inPlace) {\n    if (typeof (standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n};\n\nexports.cumulativeSum = function cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-stat/array.js\n// module id = 13\n// module chunks = 0","'use strict';\nconst database = require('../../data/data.json');\nconst EquationSet = require('./../core/EquationSet');\nconst deepcopy = require('deepcopy');\nconst Equilibrium = require('./../core/Equilibrium');\n\nconst defaultOptions = {\n    solvent: 'H2O'\n};\n\nclass Helper {\n    constructor(options) {\n        this.atEquilibrium = new Set();\n        options = Object.assign({}, defaultOptions, options);\n        var db = options.database || database;\n        if (options.extend && options.database) db = db.concat(database);\n        db = processDB(db, options);\n        this.species = {};\n        this.options = options;\n        this.eqSet = new EquationSet(db);\n        this.addSpecie(options.solvent);\n    }\n\n    // Clone\n    clone() {\n        var helper = new Helper();\n        helper.species = deepcopy(this.species);\n        helper.eqSet = this.eqSet.clone();\n        helper.options = deepcopy(this.options);\n        helper.atEquilibrium = new Set(this.atEquilibrium);\n        return helper;\n    }\n\n    // =========== Getters ==============\n\n    getSpecies(options) {\n        options = options || {};\n        var species = options.filtered ? Object.keys(this.species) : null;\n        var getOptions = Object.assign({}, options);\n        getOptions.species = species;\n        return this.eqSet.getSpecies(getOptions);\n    }\n\n\n    getComponents(options) {\n        options = options || {};\n        var species = options.filtered ? Object.keys(this.species) : null;\n        if (species) var eqSet = this.eqSet.getSubset(species);\n        else eqSet = this.eqSet;\n        return eqSet.getNormalized(this.options.solvent).getComponents(options);\n    }\n\n    getEquations(options) {\n        options = options || {};\n        var eqSet = this.eqSet;\n        if (options.filtered) {\n            eqSet = this.eqSet.getSubset(Object.keys(this.species));\n        }\n        if (options.normalized) {\n            eqSet = eqSet.getNormalized(this.options.solvent);\n        }\n        return eqSet.getEquations(options);\n    }\n\n\n    getModel() {\n        var subSet = this.eqSet.getSubset(Object.keys(this.species));\n        var normSet = subSet.getNormalized(this.options.solvent);\n        var model = normSet.getModel(this.species, true);\n        model.components.forEach(c => {\n            if (this.atEquilibrium.has(c.label)) {\n                c.atEquilibrium = this.species[c.label];\n                delete c.total;\n            }\n        });\n        return model;\n    }\n\n    getEquilibrium() {\n        return new Equilibrium(this.getModel(), this.options);\n    }\n\n    // =========== Setters ==============\n\n    addSpecie(label, total) {\n        total = total || 0;\n        if (label === this.solvent) {\n            total = 0;\n        }\n        if (!this.species[label]) {\n            this.species[label] = total;\n        } else {\n            this.species[label] += total;\n        }\n    }\n\n    resetSpecies() {\n        this.species = {};\n        this.addSpecie(this.options.solvent);\n    }\n\n    setTotal(label, total) {\n        this.species[label] = total;\n        this.atEquilibrium.delete(label);\n    }\n\n    setAtEquilibrium(label, value) {\n        this.species[label] = value;\n        this.atEquilibrium.add(label);\n    }\n\n    setOptions(options) {\n        this.options = Object.assign({}, this.options, options);\n    }\n\n\n    disableEquation(formedSpecie) {\n        this.eqSet.disableEquation(formedSpecie, true);\n    }\n\n    enableEquation(formedSpecie) {\n        this.eqSet.enableEquation(formedSpecie, true);\n    }\n\n    enableAllEquations() {\n        this.eqSet.enableAllEquations();\n    }\n\n}\n\nmodule.exports = Helper;\n\nfunction processDB(db, options) {\n    db = deepcopy(db);\n    var toRemove = [];\n    for (var i = 0; i < db.length; i++) {\n        if (typeof db[i].pK !== 'number' || options.solvent !== 'H2O') {\n            if (!db[i].pK[options.solvent]) {\n                toRemove.push(i);\n            } else {\n                db[i].pK = db[i].pK[options.solvent];\n            }\n        }\n    }\n\n    for (i = db.length - 1; i >= 0; i--) {\n        if (toRemove.indexOf(i) > -1) {\n            db.splice(i, 1);\n        }\n    }\n\n    return db;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/Helper.js","'use strict';\n\nconst defaultOptions = {\n    chunks: 200,\n    log: false,\n    from: 0,\n    to: 1,\n    isFixed: false\n};\n\nclass Serie {\n    constructor(helper) {\n        this.helper = helper;\n    }\n\n    getTitration(options) {\n        options = Object.assign({}, defaultOptions, options);\n        // We don't want to change the original helper\n        var helper = this.helper.clone();\n        helper.resetSpecies();\n        // Some options are meant for the helper\n        // e.g. tolerance, solidTolerance, maxIterations\n        helper.setOptions(options);\n\n\n        var solVolume = options.solution.volume;\n        var solConc = options.solution.concentration;\n        var solQty = solConc * solVolume;\n\n        var titrConc = options.titrationSolution.concentration;\n        var titrVolStart = 0;\n        var titrVolStop = options.titrationSolution.volume;\n\n        var errorCount = 0;\n\n        var vols = [];\n        var ph = [];\n        var solutions = [];\n        var chunks = options.chunks;\n        var sol;\n\n        helper.addSpecie(options.solution.type);\n        helper.addSpecie(options.titrationSolution.type);\n\n        for (let i = 0; i <= chunks; i++) {\n            var vol = titrVolStart + (titrVolStop - titrVolStart) * (i / chunks);\n            var totalVol = vol + solVolume;\n            var titrQty = vol * titrConc;\n            helper.setTotal(options.titrationSolution.type, titrQty);\n            helper.setTotal(options.solution.type, solQty);\n            helper.setOptions({volume: totalVol});\n            var eq = helper.getEquilibrium();\n\n            if (!sol) {\n                sol = eq.solveRobust();\n            } else {\n                eq.setInitial(sol);\n                sol = eq.solve();\n            }\n\n            if (sol) {\n                ph.push(-Math.log10(sol['H+']));\n                solutions.push(sol);\n                vols.push(vol);\n            } else {\n                errorCount++;\n            }\n\n        }\n\n        var xy = [];\n        for (let i = 0; i < ph.length; i++) {\n            xy.push(vols[i], ph[i]);\n        }\n\n        var species = solutions[0] ? Object.keys(solutions[0]) : [];\n\n        return {\n            xy, errorCount, solutions, species,\n            volumes: vols,\n            equations: helper.getEquations({filtered: true})\n        };\n    }\n\n    getSolutions(options) {\n        options = Object.assign({}, defaultOptions, options);\n        // We don't want to change the original helper\n        var helper = this.helper.clone();\n        // Some options are meant for the helper\n        // e.g. tolerance, solidTolerance, maxIterations\n        helper.setOptions(options);\n\n        checkOptions(options);\n        var varying = options.varying;\n\n        // if(options.log) {\n        //     var [from, to] = [Math.pow(10, -options.to), Math.pow(10, -options.from)];\n        // } else {\n        //     [from, to] = [options.from, options.to];\n        // }\n\n\n        var errorCount = 0;\n        var chunks = options.chunks;\n        var sol;\n        var solutions = [];\n        var x = [];\n        var log = options.log;\n        var from = options.from;\n        var to = options.to;\n\n        // if(log) {\n        //     from = -Math.log10(Number(options.to));\n        //     to = -Math.log10(Number(options.from));\n        // } else {\n        //     from = Number(options.from);\n        //     to = Number(options.to);\n        // }\n\n        for (var i = 0; i <= chunks; i++) {\n            var val = options.from + (to - from) * i / chunks;\n\n            if (log) {\n                var realVal = Math.pow(10, -val);\n            } else {\n                realVal = val;\n            }\n            if (options.isFixed) {\n                helper.setAtEquilibrium(varying, realVal);\n            } else {\n                helper.setTotal(varying, realVal);\n            }\n            var eq = helper.getEquilibrium();\n            if (sol) {\n                eq.setInitial(sol);\n                sol = eq.solve();\n            } else {\n                sol = eq.solveRobust();\n            }\n            if (sol) {\n                x.push(val);\n                solutions.push(sol);\n            } else {\n                errorCount++;\n            }\n        }\n        return {\n            x, solutions, errorCount,\n            species: solutions[0] ? Object.keys(solutions[0]) : []\n        };\n    }\n}\n\nfunction checkOptions(options) {\n    if (options.from >= options.to) {\n        throw new Error('Invalid arguments: property \"to\" should be larger than \"from\"');\n    }\n\n    if (!options.varying) {\n        throw new Error('Invalid arguments: property \"varying\" is not defined');\n    }\n}\n\nmodule.exports = Serie;\n\n\n\n// WEBPACK FOOTER //\n// ./src/helpers/Serie.js","module.exports = [\n\t{\n\t\t\"formed\": \"HIO3\",\n\t\t\"components\": {\n\t\t\t\"IO3-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 0.8,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HOCN\",\n\t\t\"components\": {\n\t\t\t\"OCN-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 3.48,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HBrO\",\n\t\t\"components\": {\n\t\t\t\"BrO-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 8.6,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"CH2ClCO2H\",\n\t\t\"components\": {\n\t\t\t\"CH2ClCO2-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 2.89,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"C6H5COOH\",\n\t\t\"components\": {\n\t\t\t\"C6H5COO-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 4.2,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"C6H5NH3+\",\n\t\t\"components\": {\n\t\t\t\"C6H5NH2\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 4.6,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"C2H5COOH\",\n\t\t\"components\": {\n\t\t\t\"C2H5COO-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 4.87,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"C5H5NH+\",\n\t\t\"components\": {\n\t\t\t\"C5H5N\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 5.25,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"CH3NH3+\",\n\t\t\"components\": {\n\t\t\t\"CH3NH2\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 10.66,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"(C2H5)3NH+\",\n\t\t\"components\": {\n\t\t\t\"(C2H5)3N\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 10.75,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"C2H5NH3+\",\n\t\t\"components\": {\n\t\t\t\"C2H5NH2\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 10.8,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HClO4\",\n\t\t\"components\": {\n\t\t\t\"ClO4-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": -7,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HCl\",\n\t\t\"components\": {\n\t\t\t\"Cl-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": -3,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"H2SO4\",\n\t\t\"components\": {\n\t\t\t\"HSO4-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": -3,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HNO3\",\n\t\t\"components\": {\n\t\t\t\"NO3-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": -1,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"H2SO3\",\n\t\t\"components\": {\n\t\t\t\"HSO3-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 1.8,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HSO4-\",\n\t\t\"components\": {\n\t\t\t\"SO4--\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 1.9,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HClO2\",\n\t\t\"components\": {\n\t\t\t\"ClO2-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 1.93,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"H2PO3\",\n\t\t\"components\": {\n\t\t\t\"HPO3-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 2,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"Fe(H2O)6+++\",\n\t\t\"components\": {\n\t\t\t\"Fe(H2O)5OH++\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 2.1,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"H3PO4\",\n\t\t\"components\": {\n\t\t\t\"H2PO4-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 2.12,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HF\",\n\t\t\"components\": {\n\t\t\t\"F-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 3.2,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HNO2\",\n\t\t\"components\": {\n\t\t\t\"NO2-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 3.35,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HCO2H\",\n\t\t\"components\": {\n\t\t\t\"HCO2-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 3.75,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"CH3CO2H\",\n\t\t\"components\": {\n\t\t\t\"CH3COO-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 4.7,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"Al(H2O)6+++\",\n\t\t\"components\": {\n\t\t\t\"Al(H2O)5OH++\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 4.9,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"H2CO3\",\n\t\t\"components\": {\n\t\t\t\"HCO3-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 6.3,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HPO3-\",\n\t\t\"components\": {\n\t\t\t\"PO3--\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 6.59,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"H2S\",\n\t\t\"components\": {\n\t\t\t\"HS-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 7.04,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HSO3-\",\n\t\t\"components\": {\n\t\t\t\"SO3--\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 7.21,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HClO\",\n\t\t\"components\": {\n\t\t\t\"ClO-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 8,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HCN\",\n\t\t\"components\": {\n\t\t\t\"CN-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 9.2,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"NH4+\",\n\t\t\"components\": {\n\t\t\t\"NH3\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 9.25,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HCO3-\",\n\t\t\"components\": {\n\t\t\t\"CO3--\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 10.33,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"H2PO4-\",\n\t\t\"components\": {\n\t\t\t\"HPO4--\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 7.2,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HPO4--\",\n\t\t\"components\": {\n\t\t\t\"PO4---\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 12.32,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"H2O\",\n\t\t\"components\": {\n\t\t\t\"OH-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 14,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"HS-\",\n\t\t\"components\": {\n\t\t\t\"S--\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 19,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"NH3\",\n\t\t\"components\": {\n\t\t\t\"NH2-\": 1,\n\t\t\t\"H+\": 1\n\t\t},\n\t\t\"pK\": 23,\n\t\t\"type\": \"acidoBasic\"\n\t},\n\t{\n\t\t\"formed\": \"Ag(NH3)2+\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"NH3\": 2\n\t\t},\n\t\t\"pK\": 7.2,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Zn(NH3)4++\",\n\t\t\"components\": {\n\t\t\t\"Zn++\": 1,\n\t\t\t\"NH3\": 4\n\t\t},\n\t\t\"pK\": 8.89,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Cu(NH3)4++\",\n\t\t\"components\": {\n\t\t\t\"Cu++\": 1,\n\t\t\t\"NH3\": 4\n\t\t},\n\t\t\"pK\": 13.04,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Hg(NH3)4++\",\n\t\t\"components\": {\n\t\t\t\"Hg++\": 1,\n\t\t\t\"NH3\": 4\n\t\t},\n\t\t\"pK\": 19.26,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Co(NH3)6++\",\n\t\t\"components\": {\n\t\t\t\"Co++\": 1,\n\t\t\t\"NH3\": 6\n\t\t},\n\t\t\"pK\": 4.7,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Co(NH3)4+++\",\n\t\t\"components\": {\n\t\t\t\"Co+++\": 1,\n\t\t\t\"NH3\": 4\n\t\t},\n\t\t\"pK\": 33.66,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Cd(NH3)6++\",\n\t\t\"components\": {\n\t\t\t\"Cd++\": 1,\n\t\t\t\"NH3\": 6\n\t\t},\n\t\t\"pK\": 5.41,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Cd(NH3)4++\",\n\t\t\"components\": {\n\t\t\t\"Cd++\": 1,\n\t\t\t\"NH3\": 4\n\t\t},\n\t\t\"pK\": 7,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Ni(NH3)6++\",\n\t\t\"components\": {\n\t\t\t\"Ni++\": 1,\n\t\t\t\"NH3\": 6\n\t\t},\n\t\t\"pK\": 8.3,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Fe(CN)6----\",\n\t\t\"components\": {\n\t\t\t\"Fe++\": 1,\n\t\t\t\"CN-\": 6\n\t\t},\n\t\t\"pK\": 35,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Fe(CN)6---\",\n\t\t\"components\": {\n\t\t\t\"Fe+++\": 1,\n\t\t\t\"CN-\": 6\n\t\t},\n\t\t\"pK\": 41.96,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Ag(CN)2-\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"CN-\": 2\n\t\t},\n\t\t\"pK\": 18.72,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Cu(CN)2-\",\n\t\t\"components\": {\n\t\t\t\"Cu+\": 1,\n\t\t\t\"CN-\": 2\n\t\t},\n\t\t\"pK\": 16,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Cd(CN)4--\",\n\t\t\"components\": {\n\t\t\t\"Cd++\": 1,\n\t\t\t\"CN-\": 4\n\t\t},\n\t\t\"pK\": 16.89,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Au(CN)2-\",\n\t\t\"components\": {\n\t\t\t\"Au+\": 1,\n\t\t\t\"CN-\": 2\n\t\t},\n\t\t\"pK\": 38.3,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Ni(CN)4--\",\n\t\t\"components\": {\n\t\t\t\"Ni++\": 1,\n\t\t\t\"CN-\": 4\n\t\t},\n\t\t\"pK\": 31,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"AlF6---\",\n\t\t\"components\": {\n\t\t\t\"Al+++\": 1,\n\t\t\t\"F-\": 6\n\t\t},\n\t\t\"pK\": 4.4,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"AlF4-\",\n\t\t\"components\": {\n\t\t\t\"Al+++\": 1,\n\t\t\t\"F-\": 4\n\t\t},\n\t\t\"pK\": 8.3,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"BeF4--\",\n\t\t\"components\": {\n\t\t\t\"Be++\": 1,\n\t\t\t\"F-\": 4\n\t\t},\n\t\t\"pK\": 13.11,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"SnF6--\",\n\t\t\"components\": {\n\t\t\t\"Sn++++\": 1,\n\t\t\t\"F-\": 6\n\t\t},\n\t\t\"pK\": 25,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"CuCl2-\",\n\t\t\"components\": {\n\t\t\t\"Cu+\": 1,\n\t\t\t\"Cl-\": 2\n\t\t},\n\t\t\"pK\": 5.48,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"AgCl2-\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"Cl-\": 2\n\t\t},\n\t\t\"pK\": 5.26,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"PbCl4--\",\n\t\t\"components\": {\n\t\t\t\"Pb++\": 1,\n\t\t\t\"Cl-\": 4\n\t\t},\n\t\t\"pK\": 15.4,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"HgCl4--\",\n\t\t\"components\": {\n\t\t\t\"Hg++\": 1,\n\t\t\t\"Cl-\": 4\n\t\t},\n\t\t\"pK\": 15.7,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"CuBr2-\",\n\t\t\"components\": {\n\t\t\t\"Cu+\": 1,\n\t\t\t\"Br-\": 2\n\t\t},\n\t\t\"pK\": 5.9,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"AgBr2-\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"Br-\": 2\n\t\t},\n\t\t\"pK\": 11,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"HgBr4--\",\n\t\t\"components\": {\n\t\t\t\"Hg++\": 1,\n\t\t\t\"Br-\": 4\n\t\t},\n\t\t\"pK\": 4.48,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"CuI2-\",\n\t\t\"components\": {\n\t\t\t\"Cu+\": 1,\n\t\t\t\"I-\": 2\n\t\t},\n\t\t\"pK\": 8.9,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"AgI2-\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"I-\": 2\n\t\t},\n\t\t\"pK\": 11,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"PbI4--\",\n\t\t\"components\": {\n\t\t\t\"Pb++\": 1,\n\t\t\t\"I-\": 4\n\t\t},\n\t\t\"pK\": 4.48,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"HgI4--\",\n\t\t\"components\": {\n\t\t\t\"Hg++\": 1,\n\t\t\t\"I-\": 4\n\t\t},\n\t\t\"pK\": 30.28,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Ag(CH3NH2)2+\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"CH3NH2\": 2\n\t\t},\n\t\t\"pK\": 6.89,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Ag(S2O3)2---\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"S2O3--\": 2\n\t\t},\n\t\t\"pK\": 13.46,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Cd(SCN)4--\",\n\t\t\"components\": {\n\t\t\t\"Cd++\": 1,\n\t\t\t\"SCN-\": 4\n\t\t},\n\t\t\"pK\": 3,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Cu(SCN)2\",\n\t\t\"components\": {\n\t\t\t\"Cu++\": 1,\n\t\t\t\"SCN-\": 2\n\t\t},\n\t\t\"pK\": 3.75,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Fe(SCN)3\",\n\t\t\"components\": {\n\t\t\t\"Fe+++\": 1,\n\t\t\t\"SCN-\": 3\n\t\t},\n\t\t\"pK\": 6.3,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Hg(SCN)4--\",\n\t\t\"components\": {\n\t\t\t\"Hg++\": 1,\n\t\t\t\"SCN-\": 4\n\t\t},\n\t\t\"pK\": 21.7,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Cu(OH)4--\",\n\t\t\"components\": {\n\t\t\t\"Cu++\": 1,\n\t\t\t\"OH-\": 4\n\t\t},\n\t\t\"pK\": 16.11,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Zn(OH)4--\",\n\t\t\"components\": {\n\t\t\t\"Zn++\": 1,\n\t\t\t\"OH-\": 4\n\t\t},\n\t\t\"pK\": 15.45,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Mn(en)3++\",\n\t\t\"components\": {\n\t\t\t\"Mn++\": 1,\n\t\t\t\"en\": 1\n\t\t},\n\t\t\"pK\": 5.81,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Fe(en)3++\",\n\t\t\"components\": {\n\t\t\t\"Fe++\": 1,\n\t\t\t\"en\": 1\n\t\t},\n\t\t\"pK\": 9.72,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Co(en)3++\",\n\t\t\"components\": {\n\t\t\t\"Co++\": 1,\n\t\t\t\"en\": 1\n\t\t},\n\t\t\"pK\": 14.11,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Co(en)3+++\",\n\t\t\"components\": {\n\t\t\t\"Co+++\": 1,\n\t\t\t\"en\": 1\n\t\t},\n\t\t\"pK\": 48.68,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Ni(en)3++\",\n\t\t\"components\": {\n\t\t\t\"Ni++\": 1,\n\t\t\t\"en\": 1\n\t\t},\n\t\t\"pK\": 17.61,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Cu(en)2++\",\n\t\t\"components\": {\n\t\t\t\"Cu++\": 1,\n\t\t\t\"en\": 1\n\t\t},\n\t\t\"pK\": 19.54,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Co(C2O4)3----\",\n\t\t\"components\": {\n\t\t\t\"Co++\": 1,\n\t\t\t\"C2O4--\": 3\n\t\t},\n\t\t\"pK\": 6.65,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"Fe(C2O4)3---\",\n\t\t\"components\": {\n\t\t\t\"Fe+++\": 1,\n\t\t\t\"C2O4--\": 3\n\t\t},\n\t\t\"pK\": 20.52,\n\t\t\"type\": \"complexation\"\n\t},\n\t{\n\t\t\"formed\": \"AgBr\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"Br-\": 1\n\t\t},\n\t\t\"pK\": 12.27,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"AgBrO3\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"BrO3-\": 1\n\t\t},\n\t\t\"pK\": 4.24,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Ag2CO3\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 2,\n\t\t\t\"CO3--\": 1\n\t\t},\n\t\t\"pK\": 11.1,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"AgCl\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"Cl-\": 1\n\t\t},\n\t\t\"pK\": 9.74,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Ag2CrO4\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 2,\n\t\t\t\"CrO4--\": 1\n\t\t},\n\t\t\"pK\": 11.05,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"AgI\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"I-\": 1\n\t\t},\n\t\t\"pK\": 16.07,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"AgOH\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 1,\n\t\t\t\"OH-\": 1\n\t\t},\n\t\t\"pK\": 7.72,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Ag2S\",\n\t\t\"components\": {\n\t\t\t\"Ag+\": 2,\n\t\t\t\"S--\": 1\n\t\t},\n\t\t\"pK\": 50.22,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Al(OH)3\",\n\t\t\"components\": {\n\t\t\t\"Al+++\": 1,\n\t\t\t\"OH-\": 3\n\t\t},\n\t\t\"pK\": 32.74,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"BaCO3\",\n\t\t\"components\": {\n\t\t\t\"Ba++\": 1,\n\t\t\t\"CO3--\": 1\n\t\t},\n\t\t\"pK\": 8.7,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"BaCrO4\",\n\t\t\"components\": {\n\t\t\t\"Ba++\": 1,\n\t\t\t\"CrO4--\": 1\n\t\t},\n\t\t\"pK\": 10.07,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"BaF2\",\n\t\t\"components\": {\n\t\t\t\"Ba++\": 1,\n\t\t\t\"F-\": 2\n\t\t},\n\t\t\"pK\": 6.74,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"BaSO4\",\n\t\t\"components\": {\n\t\t\t\"Ba++\": 1,\n\t\t\t\"SO4--\": 1\n\t\t},\n\t\t\"pK\": 9.96,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Bi2S3\",\n\t\t\"components\": {\n\t\t\t\"Bi+++\": 2,\n\t\t\t\"S--\": 3\n\t\t},\n\t\t\"pK\": 71.8,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"CaCO3\",\n\t\t\"components\": {\n\t\t\t\"Ca++\": 1,\n\t\t\t\"CO3--\": 1\n\t\t},\n\t\t\"pK\": 8.47,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"CaF2\",\n\t\t\"components\": {\n\t\t\t\"Ca++\": 1,\n\t\t\t\"F-\": 2\n\t\t},\n\t\t\"pK\": 10.46,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Ca(OH)2\",\n\t\t\"components\": {\n\t\t\t\"Ca++\": 1,\n\t\t\t\"OH-\": 2\n\t\t},\n\t\t\"pK\": 5.3,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Ca3(PO4)2\",\n\t\t\"components\": {\n\t\t\t\"Ca++\": 3,\n\t\t\t\"PO4---\": 2\n\t\t},\n\t\t\"pK\": 32.68,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"CaSO4\",\n\t\t\"components\": {\n\t\t\t\"Ca++\": 1,\n\t\t\t\"SO4--\": 1\n\t\t},\n\t\t\"pK\": 4.35,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"CdS\",\n\t\t\"components\": {\n\t\t\t\"Cd++\": 1,\n\t\t\t\"S--\": 1\n\t\t},\n\t\t\"pK\": 28,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"CuCl\",\n\t\t\"components\": {\n\t\t\t\"Cu+\": 1,\n\t\t\t\"Cl-\": 1\n\t\t},\n\t\t\"pK\": 6.77,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Cu(OH)2\",\n\t\t\"components\": {\n\t\t\t\"Cu++\": 1,\n\t\t\t\"OH-\": 2\n\t\t},\n\t\t\"pK\": 18.8,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"CuS\",\n\t\t\"components\": {\n\t\t\t\"Cu++\": 1,\n\t\t\t\"S--\": 1\n\t\t},\n\t\t\"pK\": 44.07,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Fe(OH)2\",\n\t\t\"components\": {\n\t\t\t\"Fe++\": 1,\n\t\t\t\"OH-\": 2\n\t\t},\n\t\t\"pK\": 16.31,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Fe(OH)3\",\n\t\t\"components\": {\n\t\t\t\"Fe+++\": 1,\n\t\t\t\"OH-\": 3\n\t\t},\n\t\t\"pK\": 38.55,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"FeS\",\n\t\t\"components\": {\n\t\t\t\"Fe++\": 1,\n\t\t\t\"S--\": 1\n\t\t},\n\t\t\"pK\": 18.22,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Hg2Cl2\",\n\t\t\"components\": {\n\t\t\t\"Hg+\": 2,\n\t\t\t\"Cl-\": 2\n\t\t},\n\t\t\"pK\": 17.85,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Li2CO3\",\n\t\t\"components\": {\n\t\t\t\"Li+\": 2,\n\t\t\t\"CO3--\": 1\n\t\t},\n\t\t\"pK\": 2.96,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"MgCO3\",\n\t\t\"components\": {\n\t\t\t\"Mg++\": 1,\n\t\t\t\"CO3--\": 1\n\t\t},\n\t\t\"pK\": 4.17,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Mg(OH)2\",\n\t\t\"components\": {\n\t\t\t\"Mg++\": 1,\n\t\t\t\"OH-\": 2\n\t\t},\n\t\t\"pK\": 11.15,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Mn(OH)2\",\n\t\t\"components\": {\n\t\t\t\"Mn--\": 1,\n\t\t\t\"OH-\": 2\n\t\t},\n\t\t\"pK\": 12.7,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"PbCl2\",\n\t\t\"components\": {\n\t\t\t\"Pb++\": 1,\n\t\t\t\"Cl-\": 2\n\t\t},\n\t\t\"pK\": 4.77,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"PbCrO4\",\n\t\t\"components\": {\n\t\t\t\"Pb++\": 1,\n\t\t\t\"CrO4--\": 1\n\t\t},\n\t\t\"pK\": 15.7,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"PbI2\",\n\t\t\"components\": {\n\t\t\t\"Pb++\": 1,\n\t\t\t\"I--\": 2\n\t\t},\n\t\t\"pK\": 7.85,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Pb(OH)2\",\n\t\t\"components\": {\n\t\t\t\"Pb++\": 1,\n\t\t\t\"OH-\": 2\n\t\t},\n\t\t\"pK\": 14.92,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"PbS\",\n\t\t\"components\": {\n\t\t\t\"Pb++\": 1,\n\t\t\t\"S--\": 1\n\t\t},\n\t\t\"pK\": 28.15,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"PbSO4\",\n\t\t\"components\": {\n\t\t\t\"Pb++\": 1,\n\t\t\t\"SO4--\": 1\n\t\t},\n\t\t\"pK\": 7.8,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"Zn(OH)2\",\n\t\t\"components\": {\n\t\t\t\"Zn++\": 1,\n\t\t\t\"OH-\": 2\n\t\t},\n\t\t\"pK\": 16.35,\n\t\t\"type\": \"precipitation\"\n\t},\n\t{\n\t\t\"formed\": \"ZnS\",\n\t\t\"components\": {\n\t\t\t\"Zn++\": 1,\n\t\t\t\"S--\": 1\n\t\t},\n\t\t\"pK\": 22.52,\n\t\t\"type\": \"precipitation\"\n\t}\n];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./data/data.json\n// module id = 16\n// module chunks = 0","'use strict';\n\nconst deepcopy = require('deepcopy');\nconst types = ['acidoBasic', 'precipitation', 'complexation'];\nclass Equation {\n    constructor(eq) {\n        // Sanity checks\n        if (typeof eq.formed !== 'string') throw new Error('equation expects a property \"formed\" that is a string');\n        if (typeof eq.pK !== 'number') throw new Error('equation expects a property \"pK\" that is a number');\n        if (types.indexOf(eq.type) === -1) throw new Error('Unexpected type');\n        if (Object.prototype.toString.call(eq.components) !== '[object Object]') throw new Error('Unexpected components');\n        if (Object.keys(eq.components).length < 1) throw new Error('Components is expected to have at least one key');\n\n        this._eq = deepcopy(eq);\n    }\n\n    static create(eq) {\n        if (eq instanceof Equation) {\n            return eq.clone();\n        } else {\n            return new Equation(eq);\n        }\n    }\n\n    get pK() {\n        return this._eq.pK;\n    }\n\n    get formed() {\n        return this._eq.formed;\n    }\n\n    get components() {\n        return this._eq.components;\n    }\n\n    get type() {\n        return this._eq.type;\n    }\n\n    clone() {\n        return new Equation(deepcopy(this._eq));\n    }\n\n    toJSON() {\n        return this._eq;\n    }\n\n    // Get a new representation of the equation given a solvent\n    // Returns a new equation that does not include the solvent\n    withSolvent(solvent) {\n        var eq = {};\n        var comp = this._eq.components;\n        var formed = this._eq.formed;\n        var compKeys = Object.keys(comp);\n        if (formed === solvent) {\n            eq.formed = compKeys[0];\n            eq.components = {};\n            eq.pK = -this._eq.pK;\n            eq.type = this._eq.type;\n            for (let j = 1; j < compKeys.length; j++) {\n                let compKey = compKeys[j];\n                eq.components[compKey] = -this._eq.components[compKey];\n            }\n        } else {\n            for (let j = 0; j < compKeys.length; j++) {\n                let compKey = compKeys[j];\n                if (compKey === solvent) {\n                    eq = deepcopy(this._eq);\n                    // Remove solvent from equation\n                    delete eq.components[compKey];\n                    break;\n                }\n            }\n        }\n        if (!eq.components) {\n            return this.clone();\n        }\n\n        return new Equation(eq);\n    }\n}\n\n\nmodule.exports = Equation;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/Equation.js","'use strict';\n\nconst Equation = require('./Equation');\nclass EquationSet {\n    constructor(equations) {\n        equations = equations || [];\n        this._normalized = false;\n        this._disabledKeys = new Set();\n        this._equations = new Map();\n        for (var i = 0; i < equations.length; i++) {\n            this.add(equations[i]);\n        }\n    }\n\n    [Symbol.iterator]() {\n        return this._equations.values();\n    }\n\n    clone() {\n        var eqSet = new EquationSet();\n        eqSet._normalized = this._normalized;\n        eqSet._disabledKeys = this._disabledKeys;\n        for (const [key, eq] of this.entries()) {\n            eqSet._equations.set(key, eq.clone());\n        }\n        return eqSet;\n    }\n\n    add(eq, key) {\n        var equation = Equation.create(eq);\n        key = key || getHash(eq.formed);\n        this._equations.set(key, equation);\n        this._normalized = false;\n    }\n\n    has(eq) {\n        if (eq instanceof Equation) {\n            var key = getHash(eq.formed);\n        } else {\n            key = eq;\n        }\n        return this._equations.has(key);\n    }\n\n    get species() {\n        return this.getSpecies();\n    }\n\n    getSpecies(options) {\n        options = Object.assign({}, options);\n        var species = options.species;\n        var type = options.type;\n        var includeDisabled = options.includeDisabled;\n        var speciesSet = new Set();\n\n        if (species) {\n            var subset = this.getSubset(species);\n            delete options.species;\n            return subset.getSpecies(options);\n        } else {\n            for (var [key, eq] of this.entries()) {\n                if (this._disabledKeys.has(key) && !includeDisabled) continue;\n                if (type && type !== eq.type) continue;\n                speciesSet.add(eq.formed);\n                Object.keys(eq.components).forEach(c => speciesSet.add(c));\n            }\n        }\n        return Array.from(speciesSet);\n    }\n\n\n    get components() {\n        return this.getComponents();\n    }\n\n    getComponents(options) {\n        options = options || {};\n        var species = options.species;\n        var type = options.type;\n        var includeDisabled = options.includeDisabled;\n        if (!this.isNormalized()) {\n            throw new Error('Cannot get components from non-normalized equation set');\n        }\n        var speciesSet = new Set();\n        for (var [key, eq] of this.entries()) {\n            if (this._disabledKeys.has(key) && !includeDisabled) continue;\n            if (type && type !== eq.type) continue;\n            if (species) {\n                if (species.indexOf(eq.formed) > -1) {\n                    Object.keys(eq.components).forEach(c => speciesSet.add(c));\n                } else {\n                    Object.keys(eq.components).forEach(c => {\n                        if (species.indexOf(c) > -1) speciesSet.add(c);\n                    });\n                }\n            } else {\n                Object.keys(eq.components).forEach(c => speciesSet.add(c));\n            }\n\n        }\n        return Array.from(speciesSet);\n    }\n\n    disableEquation(key, hashIt) {\n        key = hashIt ? getHash(key) : key;\n        this._disabledKeys.add(key);\n    }\n\n    enableEquation(key, hashIt) {\n        key = hashIt ? getHash(key) : key;\n        this._disabledKeys.delete(key);\n    }\n\n    enableAllEquations() {\n        this._disabledKeys.clear();\n    }\n\n    get size() {\n        return this._equations.size;\n    }\n\n    get(id, hashIt) {\n        var key;\n        if (hashIt) {\n            key = getHash(id);\n        } else {\n            key = id;\n        }\n        return this._equations.get(key);\n    }\n\n    keys() {\n        return this._equations.keys();\n    }\n\n    values() {\n        return this._equations.values();\n    }\n\n    entries() {\n        return this._equations.entries();\n    }\n\n    forEach() {\n        return this._equations.forEach.apply(this._equations, arguments);\n    }\n\n\n    getNormalized(solvent) {\n        // In a normalized set, formed species can be found in any of the components\n        // of the equation set\n        var norm = new Array(this._equations.size);\n        var keys = new Array(this._equations.size);\n        var idx = 0;\n        for (const [key, entry] of this.entries()) {\n            norm[idx] = entry.withSolvent(solvent);\n            keys[idx] = key;\n            idx++;\n        }\n        norm = normalize(norm);\n\n        var normSet = new EquationSet();\n        for (var i = 0; i < norm.length; i++) {\n            normSet.add(norm[i], keys[i]);\n        }\n\n        // return a new equation set that has been normalized\n        // normalization requires the solvent to be set\n        normSet._normalized = true;\n        normSet._disabledKeys = new Set(this._disabledKeys);\n        return normSet;\n    }\n\n    isNormalized() {\n        return this._normalized;\n    }\n\n    getEquations(options) {\n        options = options || {};\n        return Array.from(this._equations)\n            .filter(e => options.includeDisabled || !this._disabledKeys.has(e[0]))\n            .map(e => {\n                var r = e[1].toJSON();\n                if (this._disabledKeys.has(e[0])) r.disabled = true;\n                return r;\n            });\n    }\n\n    getModel(totals, all) {\n        if (!this.isNormalized()) {\n            throw new Error('Cannot get model from un-normalized equation set');\n        }\n        var totalComp = {};\n        if (all) {\n            var subset = this;\n        } else {\n            subset = this.getSubset(Object.keys(totals));\n        }\n        var components = subset.components;\n        const subsetKeys = [...subset.keys()];\n        const subsetArr = [...subset.values()]\n            .filter((s, idx) => !this._disabledKeys.has(subsetKeys[idx]));\n        components.forEach(c => totalComp[c] = 0);\n        for (var key in totals) {\n            var total = totals[key] || 0;\n            if (components.indexOf(key) !== -1) {\n                totalComp[key] += total;\n            } else {\n                var eq = subsetArr.find(eq => {\n                    return eq.formed === key;\n                });\n                if (eq) {\n                    var keys = Object.keys(eq.components);\n                    for (var i = 0; i < keys.length; i++) {\n                        totalComp[keys[i]] += eq.components[keys[i]] * total;\n                    }\n                }\n            }\n        }\n\n        var model = {\n            volume: 1\n        };\n\n        model.components = components.map(key => {\n            return {\n                label: key,\n                total: totalComp[key]\n            };\n        });\n\n        model.formedSpecies = subsetArr.map(eq => {\n            return {\n                solid: eq.type === 'precipitation',\n                label: eq.formed,\n                beta: Math.pow(10, eq.pK),\n                components: components.map(key => {\n                    return eq.components[key] || 0;\n                })\n            };\n        });\n\n        return model;\n    }\n\n    getSubset(species) {\n        var speciesSet = new Set(species);\n        // get a subset of the equations given a set of species\n        var newSet = new EquationSet();\n        var moreAdded = true;\n        var passes = 0;\n\n        var f = (species) => {\n            passes++;\n            if (passes === 10) return;\n            this.forEach(function (eq) {\n                if (species.includes(eq.formed) && !newSet.has(eq)) {\n                    newSet.add(eq);\n                    speciesSet.add(eq.formed);\n                    var newComponents = Object.keys(eq.components);\n                    newComponents.forEach(s => speciesSet.add(s));\n                    f(newComponents);\n                }\n            });\n        };\n\n        f(species);\n\n\n        if (passes === 10) {\n            throw new Error('You might have a circular dependency in your equations');\n        }\n\n        moreAdded = true;\n        passes = 0;\n        while (passes <= 10 && moreAdded) {\n            passes++;\n            moreAdded = false;\n            this.forEach(function (eq) {\n                var hasAll = Object.keys(eq.components).every(c => speciesSet.has(c));\n                if (hasAll && !newSet.has(eq)) {\n                    newSet.add(eq);\n                    speciesSet.add(eq.formed);\n                    moreAdded = true;\n                }\n            });\n        }\n\n        if (passes === 10) {\n            throw new Error('You might have a circular dependency in your equations');\n        }\n\n        // Pass along some properties\n        newSet._disabledKeys = new Set(this._disabledKeys);\n        newSet._normalized = this._normalized;\n        return newSet;\n    }\n}\n\nmodule.exports = EquationSet;\n\nfunction normalize(equations) {\n    var N = equations.length;\n    var newEquations = new Array(N).fill(0);\n    var needs = new Array(N);\n\n    // First, find the independent equations\n    for (let i = 0; i < N; i++) {\n        if (isIndependent(equations, i)) {\n            newEquations[i] = equations[i];\n        } else {\n            var keys = Object.keys(equations[i].components);\n            needs[i] = keys.map(function (key) {\n                return equations.findIndex(function (eq) {\n                    return eq.formed === key;\n                });\n            });\n        }\n    }\n\n    var iter = 0;\n    while (!allDefined(newEquations) && iter < 10) {\n        for (let i = 0; i < N; i++) {\n            if (!newEquations[i]) {\n                if (allDefined(newEquations, needs[i])) {\n                    fillLine(equations, newEquations, i);\n                }\n            }\n        }\n        iter++;\n    }\n    if (!allDefined(newEquations)) {\n        throw new Error('There may be a circular dependency in the equations');\n    }\n    return newEquations;\n}\n\nfunction isIndependent(equations, idx) {\n    var keys = Object.keys(equations[idx].components);\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var eq = equations.find(function (eq) {\n            return eq.formed === key;\n        });\n        if (eq) return false;\n    }\n    return true;\n}\n\nfunction allDefined(arr, idx) {\n    if (idx !== undefined) {\n        return !idx.some(function (idx) {\n            return idx !== -1 && !arr[idx];\n        });\n    } else {\n        return !arr.some(function (el) {\n            return el === 0;\n        });\n    }\n}\n\nfunction fillLine(equations, newEquations, i) {\n    var eq = equations[i];\n    var newEq = {\n        type: eq.type,\n        formed: eq.formed,\n        components: {}\n    };\n    fillRec(equations, eq, newEq, 1);\n    newEquations[i] = newEq;\n}\n\nfunction fillRec(equations, eq, eqToFill, n) {\n    var componentsToFill = eqToFill.components;\n    var components = eq.components;\n    var keys = Object.keys(components);\n    for (let j = 0; j < keys.length; j++) {\n        var key = keys[j];\n        let nn = n * components[key];\n        var rep = equations.find(eq => eq.formed === keys[j]);\n        if (!rep) {\n            componentsToFill[keys[j]] = componentsToFill[keys[j]] || 0;\n            componentsToFill[keys[j]] += nn;\n        } else {\n            fillRec(equations, rep, eqToFill, nn);\n        }\n    }\n    eqToFill.pK = eqToFill.pK || 0;\n    eqToFill.pK += n * eq.pK;\n}\n\nfunction getHash(id) {\n    return new Buffer(id).toString('base64');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/EquationSet.js","'use strict';\nconst Matrix = require('ml-matrix');\nconst stat = require('ml-stat').matrix;\nconst debug = require('debug')('core:newton-rahpton');\n\nconst defaultOptions = {\n    tolerance: 1e-15,\n    solidTolerance: 1e-5,\n    maxIterations: 99\n};\n\nfunction newtonRaphton(model, beta, cTotal, c, solidModel, solidKsp, solidC, options) {\n    // c is component concentrations. The initialization is up to the caller\n    // model contains stoechiometric coefficient of the reactions\n    // beta is the equilibrium constant for each reaction\n    // cTotal is the total concentration of each component\n    // solid model contains stoechiometric coefficients of the precipitation reactions\n    // solidKsp contains the solubility constants\n    // solidC contains the initial solid species \"concentrations\"\n\n    options = Object.assign({}, defaultOptions, options);\n    const ncomp = cTotal.length;\n    const nspec = beta.length;\n\n    if (!solidModel) solidModel = new Array(ncomp).fill(0).map(() => []);\n    if (!solidKsp) solidKsp = [];\n    if (!solidC) solidC = [];\n\n    const nsolid = solidKsp.length;\n\n    // Sanity check\n    if (c.length !== ncomp || model.length !== ncomp || model[0].length !== nspec || solidC.length !== nsolid || solidModel.length !== ncomp || solidModel[0] && solidModel[0].length !== nsolid) {\n        throw new Error('Invalid arguments');\n    }\n\n    model = new Matrix(model);\n    if (nsolid) {\n        solidModel = new Matrix(solidModel);\n        var lnSolidBeta = new Matrix([solidKsp.map(Math.log2)]);\n        solidC = new Matrix([solidC]);\n    }\n    // Prevent numerical difficulties\n    for (var i = 0; i < cTotal.length; i++) {\n        if (cTotal[i] === 0) cTotal[i] = options.tolerance;\n    }\n\n    c = new Matrix([c]);\n\n\n    for (i = 0; i < options.maxIterations; i++) {\n        // console.log('iteration' , i);\n        // console.log(c, solidC)\n\n        // First we determine which solids are not completely dissolved and need to be included in newton\n        // For this we compute the solubility products and compare it to the equilibrium constants\n        var solidIndices = [];\n        if (nsolid) {\n            var Ksp = stat.product(c.transpose().repeat(1, nsolid).pow(solidModel), 0);\n            Ksp.forEach((k, idx) => {\n                if (k > solidKsp[idx]) {\n                    // The computed solubility product is greater than maximum value\n                    solidIndices.push(idx);\n                } else if (solidC[0][idx] > 0) {\n                    // solid concentration is not 0\n                    solidIndices.push(idx);\n                } else if (Math.abs(k - solidKsp[idx]) < options.tolerance) {\n                    // diff is negative but small, we keep it in the model\n                    solidIndices.push(idx);\n                }\n            });\n            //solidIndices = getRange(0, solidC[0].length -1);\n            var lnKsp = Ksp.slice();\n            for (j = 0; j < lnKsp.length; j++) {\n                lnKsp[j] = Math.log2(lnKsp[j]);\n            }\n        }\n\n        // console.log(solidIndices);\n        var nSolidPicked = solidIndices.length;\n        if (nSolidPicked) {\n            var solidCPicked = solidC.selection([0], solidIndices);\n            var solidModelPicked = solidModel.selection(getRange(0, ncomp - 1), solidIndices);\n        }\n\n        var njstar = ncomp + nSolidPicked;\n\n\n        // Calculate all species concentrations from component concentrations\n        // console.log('c', c.to1DArray());\n        var cSpec = Matrix.multiply([stat.product(c.transpose().repeat(1, nspec).pow(model), 0)], [beta]);\n        // console.log('cSpec', cSpec);\n        // Compute total concentration of each component based on dissolved species\n        var cTotCalc = new Matrix([stat.sum(Matrix.multiply(cSpec.repeat(ncomp, 1), model), 1)]);\n\n        // console.log('number of solids', nSolidPicked);\n        // Add to it \"concentrations\" based on solid species\n        if (nsolid) {\n            cTotCalc.add([stat.sum(Matrix.multiply(solidC.repeat(ncomp, 1), solidModel), 1)]);\n        }\n\n        // console.log(cTotal, cTotCalc);\n        // d is the difference between expected total concentration and actual total concentration given\n        // console.log('cTotCalc', cTotCalc.to1DArray());\n        var d = Matrix.subtract([cTotal], cTotCalc);\n        if (nSolidPicked) {\n            var dK = Matrix.subtract(lnSolidBeta, [lnKsp]).selection([0], solidIndices);\n            var dkOrig = Matrix.subtract([solidKsp], [Ksp]);\n            var dAll = new Matrix(1, njstar);\n            dAll.setSubMatrix(d, 0, 0);\n            dAll.setSubMatrix(dK, 0, ncomp);\n        } else {\n            dAll = d;\n        }\n\n        // console.log('diff solution', d.to1DArray());\n        if (nsolid) {\n            // console.log('solidC', solidC.to1DArray());\n            // console.log('picked ids', solidIndices);\n        }\n\n        // console.log('dkorig', dkOrig[0]);\n        if (checkEpsilon(options.tolerance, d[0]) && checkSolid(options.solidTolerance, solidC, dkOrig)) {\n            // console.log('final solution concentrations',c);\n            // console.log('final solid concentrations', solidC);\n            debug(`solution converged in ${i} iterations`);\n            return cSpec.to1DArray().concat(solidC.to1DArray ? solidC.to1DArray() : solidC);\n        }\n\n\n        // We decompose the Jacobian (Jstar is symetric and easier to inverse)\n        var Jstar = new Matrix(njstar, njstar).fill(0);\n\n        // Fill the part of Jstar specific to dissolved variables\n        for (var j = 0; j < ncomp; j++) {\n            for (var k = j; k < ncomp; k++) {\n                for (var l = 0; l < nspec; l++) {\n                    Jstar[j][k] += model[k][l] * model[j][l] * cSpec[0][l];\n                    Jstar[k][j] = Jstar[j][k];\n                }\n            }\n        }\n\n        // Fill the part of jstar specific to solid part\n        for (j = 0; j < ncomp; j++) {\n            for (k = 0; k < nSolidPicked; k++) {\n                var jk = k + ncomp;\n                Jstar[j][jk] = solidModelPicked[j][k];\n                Jstar[jk][j] = solidModelPicked[j][k];\n            }\n        }\n\n\n        // console.log('jstar', Jstar);\n        // console.log('inter', d, d.mmul(Jstar.inv()));\n        // We compute the next delta of component concentrations and apply it to the current component concentrations\n        var diag = Matrix.identity(njstar).setSubMatrix(Matrix.diag(c[0]), 0, 0);\n        var deltaC = dAll.mmul(Jstar.inverse()).mmul(diag);\n\n        var allC = new Matrix(1, njstar);\n        allC.setSubMatrix(c, 0, 0);\n        if (nSolidPicked) {\n            allC.setSubMatrix(solidCPicked, 0, ncomp);\n        }\n        // console.log('deltaC', deltaC);\n        allC.add(deltaC);\n        // console.log('c', c);\n        // c should be positive. If it's not we want to subtract some of the deltaC we've added\n        // We do this iteratively until either nothing is negative anymore or deltaC has become very small\n        while (checkNeg(allC[0])) {\n            deltaC = deltaC.multiply(0.5);\n            allC.subtract(deltaC);\n            if (checkEpsilon(options.tolerance, deltaC[0])) break;\n        }\n\n        // console.log('allC', allC.to1DArray());\n\n        for (j = 0; j < c.columns; j++) {\n            c.set(0, j, allC.get(0, j));\n        }\n        for (j = 0; j < nSolidPicked; j++) {\n            var val = allC.get(0, ncomp + j);\n            if (val < 0) solidC.set(0, solidIndices[j], 0);\n            else solidC.set(0, solidIndices[j], val);\n        }\n    }\n\n    if (i >= options.maxIterations) {\n        debug('did not converge');\n        return null;\n    }\n    // console.log('insoluble indices', solidIndices);\n    return cSpec.to1DArray().concat(solidC.to1DArray ? solidC.to1DArray() : solidC);\n\n}\n\nmodule.exports = newtonRaphton;\n\n// Returns true if all elements in the array are smaller than tolerance\nfunction checkEpsilon(tolerance, arr, n) {\n    return !arr.some(function (el, idx) {\n        if (n && idx >= n) return false;\n        return Math.abs(el) >= tolerance;\n    });\n}\n\nfunction checkSolid(tolerance, c, dk) {\n    if (!c.length) return true;\n    return !c[0].some(function (value, idx) {\n        if (dk[0][idx] === undefined) {\n            throw 2;\n        }\n        return value !== 0 && Math.abs(dk[0][idx]) >= tolerance;\n    });\n}\n\n// return true if any element is negative\nfunction checkNeg(arr, n) {\n    return arr.some(function (el, idx) {\n        if (n && idx >= n) return true;\n        return el <= 0;\n    });\n}\n\nfunction getRange(start, end) {\n    var arr = [];\n    for (var i = start; i <= end; i++) {\n        arr.push(i);\n    }\n    return arr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/NewtonRaphton.js","'use strict';\n\nconst Equilibrium = require('./core/Equilibrium');\nconst Helper = require('./helpers/Helper');\nconst Serie = require('./helpers/Serie');\n\nEquilibrium.Helper = Helper;\nEquilibrium.Serie = Serie;\n\nmodule.exports = Equilibrium;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict';\n\nexports.logarithmic = function (random, len) {\n    if (len === undefined) {\n        return Math.pow(random(), 10);\n    }\n    var arr = new Array(len);\n    for (var i = 0; i < arr.length; i++) {\n        arr[i] = Math.pow(random(), 10);\n    }\n    return arr;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/random.js","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 22\n// module chunks = 0","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/debug/src/browser.js\n// module id = 23\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/debug/src/debug.js\n// module id = 24\n// module chunks = 0","'use strict';\n\nexports.__esModule = true;\nexports.copyValue = exports.copyCollection = exports.copy = void 0;\n\nvar _polyfill = require('./polyfill');\n\nvar toString = Object.prototype.toString;\n\nfunction copy(target, customizer) {\n  var resultValue = copyValue(target);\n\n  if (resultValue !== null) {\n    return resultValue;\n  }\n\n  return copyCollection(target, customizer);\n}\n\nfunction copyCollection(target, customizer) {\n  if (typeof customizer !== 'function') {\n    throw new TypeError('customizer is must be a Function');\n  }\n\n  if (typeof target === 'function') {\n    var source = String(target);\n\n    // NOTE:\n    //\n    //   https://gist.github.com/jdalton/5e34d890105aca44399f\n    //\n    //   - https://gist.github.com/jdalton/5e34d890105aca44399f#gistcomment-1283831\n    //   - http://es5.github.io/#x15\n    //\n    //   native functions does not have prototype:\n    //\n    //       Object.toString.prototype  // => undefined\n    //       (function() {}).prototype  // => {}\n    //\n    //   but cannot detect native constructor:\n    //\n    //       typeof Object     // => 'function'\n    //       Object.prototype  // => {}\n    //\n    //   and cannot detect null binded function:\n    //\n    //       String(Math.abs)\n    //         // => 'function abs() { [native code] }'\n    //\n    //     Firefox, Safari:\n    //       String((function abs() {}).bind(null))\n    //         // => 'function abs() { [native code] }'\n    //\n    //     Chrome:\n    //       String((function abs() {}).bind(null))\n    //         // => 'function () { [native code] }'\n    if (/^\\s*function\\s*\\S*\\([^\\)]*\\)\\s*{\\s*\\[native code\\]\\s*}/.test(source)) {\n      // native function\n      return target;\n    } else {\n      // user defined function\n      return new Function('return ' + String(source))();\n    }\n  }\n\n  var targetClass = toString.call(target);\n\n  if (targetClass === '[object Array]') {\n    return [];\n  }\n\n  if (targetClass === '[object Object]' && target.constructor === Object) {\n    return {};\n  }\n\n  if (targetClass === '[object Date]') {\n    // NOTE:\n    //\n    //   Firefox need to convert\n    //\n    //   Firefox:\n    //     var date = new Date;\n    //     +date;            // 1420909365967\n    //     +new Date(date);  // 1420909365000\n    //     +new Date(+date); // 1420909365967\n    //\n    //   Chrome:\n    //     var date = new Date;\n    //     +date;            // 1420909757913\n    //     +new Date(date);  // 1420909757913\n    //     +new Date(+date); // 1420909757913\n    return new Date(target.getTime());\n  }\n\n  if (targetClass === '[object RegExp]') {\n    // NOTE:\n    //\n    //   Chrome, Safari:\n    //     (new RegExp).source => \"(?:)\"\n    //\n    //   Firefox:\n    //     (new RegExp).source => \"\"\n    //\n    //   Chrome, Safari, Firefox:\n    //     String(new RegExp) => \"/(?:)/\"\n    var regexpText = String(target),\n        slashIndex = regexpText.lastIndexOf('/');\n\n    return new RegExp(regexpText.slice(1, slashIndex), regexpText.slice(slashIndex + 1));\n  }\n\n  if ((0, _polyfill.isBuffer)(target)) {\n    var buffer = new Buffer(target.length);\n\n    target.copy(buffer);\n\n    return buffer;\n  }\n\n  var customizerResult = customizer(target);\n\n  if (customizerResult !== void 0) {\n    return customizerResult;\n  }\n\n  return null;\n}\n\nfunction copyValue(target) {\n  var targetType = typeof target;\n\n  // copy String, Number, Boolean, undefined and Symbol\n  // without null and Function\n  if (target !== null && targetType !== 'object' && targetType !== 'function') {\n    return target;\n  }\n\n  return null;\n}\n\nexports.copy = copy;\nexports.copyCollection = copyCollection;\nexports.copyValue = copyValue;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deepcopy/lib/copy.js\n// module id = 25\n// module chunks = 0","'use strict';\n\nexports.__esModule = true;\n\nvar _copy = require('./copy');\n\nvar _polyfill = require('./polyfill');\n\nfunction defaultCustomizer(target) {\n  return void 0;\n}\n\nfunction deepcopy(target) {\n  var customizer = arguments.length <= 1 || arguments[1] === void 0 ? defaultCustomizer : arguments[1];\n\n  if (target === null) {\n    // copy null\n    return null;\n  }\n\n  var resultValue = (0, _copy.copyValue)(target);\n\n  if (resultValue !== null) {\n    // copy some primitive types\n    return resultValue;\n  }\n\n  var resultCollection = (0, _copy.copyCollection)(target, customizer),\n      clone = resultCollection !== null ? resultCollection : target;\n\n  var visited = [target],\n      reference = [clone];\n\n  // recursively copy from collection\n  return recursiveCopy(target, customizer, clone, visited, reference);\n}\n\nfunction recursiveCopy(target, customizer, clone, visited, reference) {\n  if (target === null) {\n    // copy null\n    return null;\n  }\n\n  var resultValue = (0, _copy.copyValue)(target);\n\n  if (resultValue !== null) {\n    // copy some primitive types\n    return resultValue;\n  }\n\n  var keys = (0, _polyfill.getKeys)(target).concat((0, _polyfill.getSymbols)(target));\n\n  var i = void 0,\n      len = void 0;\n\n  var key = void 0,\n      value = void 0,\n      index = void 0,\n      resultCopy = void 0,\n      result = void 0,\n      ref = void 0;\n\n  for (i = 0, len = keys.length; i < len; ++i) {\n    key = keys[i];\n    value = target[key];\n    index = (0, _polyfill.indexOf)(visited, value);\n\n    resultCopy = void 0;\n    result = void 0;\n    ref = void 0;\n\n    if (index === -1) {\n      resultCopy = (0, _copy.copy)(value, customizer);\n      result = resultCopy !== null ? resultCopy : value;\n\n      if (value !== null && /^(?:function|object)$/.test(typeof value)) {\n        visited.push(value);\n        reference.push(result);\n      }\n    } else {\n      // circular reference\n      ref = reference[index];\n    }\n\n    clone[key] = ref || recursiveCopy(value, customizer, result, visited, reference);\n  }\n\n  return clone;\n}\n\nexports['default'] = deepcopy;\nmodule.exports = exports['default'];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deepcopy/lib/index.js\n// module id = 26\n// module chunks = 0","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 27\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 28\n// module chunks = 0","'use strict';\n\nconst Stat = require('ml-stat').array;\n/**\n * Function that returns an array of points given 1D array as follows:\n *\n * [x1, y1, .. , x2, y2, ..]\n *\n * And receive the number of dimensions of each point.\n * @param array\n * @param dimensions\n * @returns {Array} - Array of points.\n */\nfunction coordArrayToPoints(array, dimensions) {\n    if(array.length % dimensions !== 0) {\n        throw new RangeError('Dimensions number must be accordance with the size of the array.');\n    }\n\n    var length = array.length / dimensions;\n    var pointsArr = new Array(length);\n\n    var k = 0;\n    for(var i = 0; i < array.length; i += dimensions) {\n        var point = new Array(dimensions);\n        for(var j = 0; j < dimensions; ++j) {\n            point[j] = array[i + j];\n        }\n\n        pointsArr[k] = point;\n        k++;\n    }\n\n    return pointsArr;\n}\n\n\n/**\n * Function that given an array as follows:\n * [x1, y1, .. , x2, y2, ..]\n *\n * Returns an array as follows:\n * [[x1, x2, ..], [y1, y2, ..], [ .. ]]\n *\n * And receives the number of dimensions of each coordinate.\n * @param array\n * @param dimensions\n * @returns {Array} - Matrix of coordinates\n */\nfunction coordArrayToCoordMatrix(array, dimensions) {\n    if(array.length % dimensions !== 0) {\n        throw new RangeError('Dimensions number must be accordance with the size of the array.');\n    }\n\n    var coordinatesArray = new Array(dimensions);\n    var points = array.length / dimensions;\n    for (var i = 0; i < coordinatesArray.length; i++) {\n        coordinatesArray[i] = new Array(points);\n    }\n\n    for(i = 0; i < array.length; i += dimensions) {\n        for(var j = 0; j < dimensions; ++j) {\n            var currentPoint = Math.floor(i / dimensions);\n            coordinatesArray[j][currentPoint] = array[i + j];\n        }\n    }\n\n    return coordinatesArray;\n}\n\n/**\n * Function that receives a coordinate matrix as follows:\n * [[x1, x2, ..], [y1, y2, ..], [ .. ]]\n *\n * Returns an array of coordinates as follows:\n * [x1, y1, .. , x2, y2, ..]\n *\n * @param coordMatrix\n * @returns {Array}\n */\nfunction coordMatrixToCoordArray(coordMatrix) {\n    var coodinatesArray = new Array(coordMatrix.length * coordMatrix[0].length);\n    var k = 0;\n    for(var i = 0; i < coordMatrix[0].length; ++i) {\n        for(var j = 0; j < coordMatrix.length; ++j) {\n            coodinatesArray[k] = coordMatrix[j][i];\n            ++k;\n        }\n    }\n\n    return coodinatesArray;\n}\n\n/**\n * Tranpose a matrix, this method is for coordMatrixToPoints and\n * pointsToCoordMatrix, that because only transposing the matrix\n * you can change your representation.\n *\n * @param matrix\n * @returns {Array}\n */\nfunction transpose(matrix) {\n    var resultMatrix = new Array(matrix[0].length);\n    for(var i = 0; i < resultMatrix.length; ++i) {\n        resultMatrix[i] = new Array(matrix.length);\n    }\n\n    for (i = 0; i < matrix.length; ++i) {\n        for(var j = 0; j < matrix[0].length; ++j) {\n            resultMatrix[j][i] = matrix[i][j];\n        }\n    }\n\n    return resultMatrix;\n}\n\n/**\n * Function that transform an array of points into a coordinates array\n * as follows:\n * [x1, y1, .. , x2, y2, ..]\n *\n * @param points\n * @returns {Array}\n */\nfunction pointsToCoordArray(points) {\n    var coodinatesArray = new Array(points.length * points[0].length);\n    var k = 0;\n    for(var i = 0; i < points.length; ++i) {\n        for(var j = 0; j < points[0].length; ++j) {\n            coodinatesArray[k] = points[i][j];\n            ++k;\n        }\n    }\n\n    return coodinatesArray;\n}\n\n/**\n * Apply the dot product between the smaller vector and a subsets of the\n * largest one.\n *\n * @param firstVector\n * @param secondVector\n * @returns {Array} each dot product of size of the difference between the\n *                  larger and the smallest one.\n */\nfunction applyDotProduct(firstVector, secondVector) {\n    var largestVector, smallestVector;\n    if(firstVector.length <= secondVector.length) {\n        smallestVector = firstVector;\n        largestVector = secondVector;\n    } else {\n        smallestVector = secondVector;\n        largestVector = firstVector;\n    }\n\n    var difference = largestVector.length - smallestVector.length + 1;\n    var dotProductApplied = new Array(difference);\n\n    for (var i = 0; i < difference; ++i) {\n        var sum = 0;\n        for (var j = 0; j < smallestVector.length; ++j) {\n            sum += smallestVector[j] * largestVector[i + j];\n        }\n        dotProductApplied[i] = sum;\n    }\n\n    return dotProductApplied;\n}\n/**\n * To scale the input array between the specified min and max values. The operation is performed inplace\n * if the options.inplace is specified. If only one of the min or max parameters is specified, then the scaling\n * will multiply the input array by min/min(input) or max/max(input)\n * @param input\n * @param options\n * @returns {*}\n */\nfunction scale(input, options){\n    var y;\n    if(options.inPlace){\n        y = input;\n    }\n    else{\n        y = new Array(input.length);\n    }\n    const max = options.max;\n    const min = options.min;\n    if(typeof max === \"number\"){\n        if(typeof min === \"number\"){\n            var minMax = Stat.minMax(input);\n            var factor = (max - min)/(minMax.max-minMax.min);\n            for(var i=0;i< y.length;i++){\n                y[i]=(input[i]-minMax.min)*factor+min;\n            }\n        }\n        else{\n            var currentMin = Stat.max(input);\n            var factor = max/currentMin;\n            for(var i=0;i< y.length;i++){\n                y[i] = input[i]*factor;\n            }\n        }\n    }\n    else{\n        if(typeof min === \"number\"){\n            var currentMin = Stat.min(input);\n            var factor = min/currentMin;\n            for(var i=0;i< y.length;i++){\n                y[i] = input[i]*factor;\n            }\n        }\n    }\n    return y;\n}\n\nmodule.exports = {\n    coordArrayToPoints: coordArrayToPoints,\n    coordArrayToCoordMatrix: coordArrayToCoordMatrix,\n    coordMatrixToCoordArray: coordMatrixToCoordArray,\n    coordMatrixToPoints: transpose,\n    pointsToCoordArray: pointsToCoordArray,\n    pointsToCoordMatrix: transpose,\n    applyDotProduct: applyDotProduct,\n    scale:scale\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-array-utils/src/ArrayUtils.js\n// module id = 29\n// module chunks = 0","module.exports = exports = require('./ArrayUtils');\n\n\nexports.getEquallySpacedData = require('./getEquallySpaced').getEquallySpacedData;\nexports.SNV = require('./snv').SNV;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-array-utils/src/index.js\n// module id = 31\n// module chunks = 0","'use strict';\n\nexports.SNV = SNV;\nvar Stat = require('ml-stat').array;\n\n/**\n * Function that applies the standard normal variate (SNV) to an array of values.\n *\n * @param data - Array of values.\n * @returns {Array} - applied the SNV.\n */\nfunction SNV(data) {\n    var mean = Stat.mean(data);\n    var std = Stat.standardDeviation(data);\n    var result = data.slice();\n    for (var i = 0; i < data.length; i++) {\n        result[i] = (result[i] - mean) / std;\n    }\n    return result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-array-utils/src/snv.js\n// module id = 32\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix').Matrix;\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\nfunction CholeskyDecomposition(value) {\n    if (!(this instanceof CholeskyDecomposition)) {\n        return new CholeskyDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n    if (!value.isSymmetric()) {\n        throw new Error('Matrix is not symmetric');\n    }\n\n    var a = value,\n        dimension = a.rows,\n        l = new Matrix(dimension, dimension),\n        positiveDefinite = true,\n        i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n        var Lrowj = l[j];\n        var d = 0;\n        for (k = 0; k < j; k++) {\n            var Lrowk = l[k];\n            var s = 0;\n            for (i = 0; i < k; i++) {\n                s += Lrowk[i] * Lrowj[i];\n            }\n            Lrowj[k] = s = (a[j][k] - s) / l[k][k];\n            d = d + s * s;\n        }\n\n        d = a[j][j] - d;\n\n        positiveDefinite &= (d > 0);\n        l[j][j] = Math.sqrt(Math.max(d, 0));\n        for (k = j + 1; k < dimension; k++) {\n            l[j][k] = 0;\n        }\n    }\n\n    if (!positiveDefinite) {\n        throw new Error('Matrix is not positive definite');\n    }\n\n    this.L = l;\n}\n\nCholeskyDecomposition.prototype = {\n    get lowerTriangularMatrix() {\n        return this.L;\n    },\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var l = this.L,\n            dimension = l.rows;\n\n        if (value.rows !== dimension) {\n            throw new Error('Matrix dimensions do not match');\n        }\n\n        var count = value.columns,\n            B = value.clone(),\n            i, j, k;\n\n        for (k = 0; k < dimension; k++) {\n            for (j = 0; j < count; j++) {\n                for (i = 0; i < k; i++) {\n                    B[k][j] -= B[i][j] * l[k][i];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        for (k = dimension - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                for (i = k + 1; i < dimension; i++) {\n                    B[k][j] -= B[i][j] * l[i][k];\n                }\n                B[k][j] /= l[k][k];\n            }\n        }\n\n        return B;\n    }\n};\n\nmodule.exports = CholeskyDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/cholesky.js\n// module id = 33\n// module chunks = 0","'use strict';\n\nconst Matrix = require('../matrix').Matrix;\nconst util = require('./util');\nconst hypotenuse = util.hypotenuse;\nconst getFilled2DArray = util.getFilled2DArray;\n\nconst defaultOptions = {\n    assumeSymmetric: false\n};\n\n// https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\nfunction EigenvalueDecomposition(matrix, options) {\n    options = Object.assign({}, defaultOptions, options);\n    if (!(this instanceof EigenvalueDecomposition)) {\n        return new EigenvalueDecomposition(matrix, options);\n    }\n    matrix = Matrix.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n        throw new Error('Matrix is not a square matrix');\n    }\n\n    var n = matrix.columns,\n        V = getFilled2DArray(n, n, 0),\n        d = new Array(n),\n        e = new Array(n),\n        value = matrix,\n        i, j;\n\n    var isSymmetric = false;\n    if (options.assumeSymmetric) {\n        isSymmetric = true;\n    } else {\n        isSymmetric = matrix.isSymmetric();\n    }\n\n    if (isSymmetric) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                V[i][j] = value.get(i, j);\n            }\n        }\n        tred2(n, e, d, V);\n        tql2(n, e, d, V);\n    } else {\n        var H = getFilled2DArray(n, n, 0),\n            ort = new Array(n);\n        for (j = 0; j < n; j++) {\n            for (i = 0; i < n; i++) {\n                H[i][j] = value.get(i, j);\n            }\n        }\n        orthes(n, H, ort, V);\n        hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n}\n\nEigenvalueDecomposition.prototype = {\n    get realEigenvalues() {\n        return this.d;\n    },\n    get imaginaryEigenvalues() {\n        return this.e;\n    },\n    get eigenvectorMatrix() {\n        if (!Matrix.isMatrix(this.V)) {\n            this.V = new Matrix(this.V);\n        }\n        return this.V;\n    },\n    get diagonalMatrix() {\n        var n = this.n,\n            e = this.e,\n            d = this.d,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                X[i][j] = 0;\n            }\n            X[i][i] = d[i];\n            if (e[i] > 0) {\n                X[i][i + 1] = e[i];\n            } else if (e[i] < 0) {\n                X[i][i - 1] = e[i];\n            }\n        }\n        return X;\n    }\n};\n\nfunction tred2(n, e, d, V) {\n\n    var f, g, h, i, j, k,\n        hh, scale;\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n    }\n\n    for (i = n - 1; i > 0; i--) {\n        scale = 0;\n        h = 0;\n        for (k = 0; k < i; k++) {\n            scale = scale + Math.abs(d[k]);\n        }\n\n        if (scale === 0) {\n            e[i] = d[i - 1];\n            for (j = 0; j < i; j++) {\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n                V[j][i] = 0;\n            }\n        } else {\n            for (k = 0; k < i; k++) {\n                d[k] /= scale;\n                h += d[k] * d[k];\n            }\n\n            f = d[i - 1];\n            g = Math.sqrt(h);\n            if (f > 0) {\n                g = -g;\n            }\n\n            e[i] = scale * g;\n            h = h - f * g;\n            d[i - 1] = f - g;\n            for (j = 0; j < i; j++) {\n                e[j] = 0;\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                V[j][i] = f;\n                g = e[j] + V[j][j] * f;\n                for (k = j + 1; k <= i - 1; k++) {\n                    g += V[k][j] * d[k];\n                    e[k] += V[k][j] * f;\n                }\n                e[j] = g;\n            }\n\n            f = 0;\n            for (j = 0; j < i; j++) {\n                e[j] /= h;\n                f += e[j] * d[j];\n            }\n\n            hh = f / (h + h);\n            for (j = 0; j < i; j++) {\n                e[j] -= hh * d[j];\n            }\n\n            for (j = 0; j < i; j++) {\n                f = d[j];\n                g = e[j];\n                for (k = j; k <= i - 1; k++) {\n                    V[k][j] -= (f * e[k] + g * d[k]);\n                }\n                d[j] = V[i - 1][j];\n                V[i][j] = 0;\n            }\n        }\n        d[i] = h;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        V[n - 1][i] = V[i][i];\n        V[i][i] = 1;\n        h = d[i + 1];\n        if (h !== 0) {\n            for (k = 0; k <= i; k++) {\n                d[k] = V[k][i + 1] / h;\n            }\n\n            for (j = 0; j <= i; j++) {\n                g = 0;\n                for (k = 0; k <= i; k++) {\n                    g += V[k][i + 1] * V[k][j];\n                }\n                for (k = 0; k <= i; k++) {\n                    V[k][j] -= g * d[k];\n                }\n            }\n        }\n\n        for (k = 0; k <= i; k++) {\n            V[k][i + 1] = 0;\n        }\n    }\n\n    for (j = 0; j < n; j++) {\n        d[j] = V[n - 1][j];\n        V[n - 1][j] = 0;\n    }\n\n    V[n - 1][n - 1] = 1;\n    e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n\n    var g, h, i, j, k, l, m, p, r,\n        dl1, c, c2, c3, el1, s, s2,\n        iter;\n\n    for (i = 1; i < n; i++) {\n        e[i - 1] = e[i];\n    }\n\n    e[n - 1] = 0;\n\n    var f = 0,\n        tst1 = 0,\n        eps = Math.pow(2, -52);\n\n    for (l = 0; l < n; l++) {\n        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n        m = l;\n        while (m < n) {\n            if (Math.abs(e[m]) <= eps * tst1) {\n                break;\n            }\n            m++;\n        }\n\n        if (m > l) {\n            iter = 0;\n            do {\n                iter = iter + 1;\n\n                g = d[l];\n                p = (d[l + 1] - g) / (2 * e[l]);\n                r = hypotenuse(p, 1);\n                if (p < 0) {\n                    r = -r;\n                }\n\n                d[l] = e[l] / (p + r);\n                d[l + 1] = e[l] * (p + r);\n                dl1 = d[l + 1];\n                h = g - d[l];\n                for (i = l + 2; i < n; i++) {\n                    d[i] -= h;\n                }\n\n                f = f + h;\n\n                p = d[m];\n                c = 1;\n                c2 = c;\n                c3 = c;\n                el1 = e[l + 1];\n                s = 0;\n                s2 = 0;\n                for (i = m - 1; i >= l; i--) {\n                    c3 = c2;\n                    c2 = c;\n                    s2 = s;\n                    g = c * e[i];\n                    h = c * p;\n                    r = hypotenuse(p, e[i]);\n                    e[i + 1] = s * r;\n                    s = e[i] / r;\n                    c = p / r;\n                    p = c * d[i] - s * g;\n                    d[i + 1] = h + s * (c * g + s * d[i]);\n\n                    for (k = 0; k < n; k++) {\n                        h = V[k][i + 1];\n                        V[k][i + 1] = s * V[k][i] + c * h;\n                        V[k][i] = c * V[k][i] - s * h;\n                    }\n                }\n\n                p = -s * s2 * c3 * el1 * e[l] / dl1;\n                e[l] = s * p;\n                d[l] = c * p;\n\n            }\n            while (Math.abs(e[l]) > eps * tst1);\n        }\n        d[l] = d[l] + f;\n        e[l] = 0;\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        k = i;\n        p = d[i];\n        for (j = i + 1; j < n; j++) {\n            if (d[j] < p) {\n                k = j;\n                p = d[j];\n            }\n        }\n\n        if (k !== i) {\n            d[k] = d[i];\n            d[i] = p;\n            for (j = 0; j < n; j++) {\n                p = V[j][i];\n                V[j][i] = V[j][k];\n                V[j][k] = p;\n            }\n        }\n    }\n}\n\nfunction orthes(n, H, ort, V) {\n\n    var low = 0,\n        high = n - 1,\n        f, g, h, i, j, m,\n        scale;\n\n    for (m = low + 1; m <= high - 1; m++) {\n        scale = 0;\n        for (i = m; i <= high; i++) {\n            scale = scale + Math.abs(H[i][m - 1]);\n        }\n\n        if (scale !== 0) {\n            h = 0;\n            for (i = high; i >= m; i--) {\n                ort[i] = H[i][m - 1] / scale;\n                h += ort[i] * ort[i];\n            }\n\n            g = Math.sqrt(h);\n            if (ort[m] > 0) {\n                g = -g;\n            }\n\n            h = h - ort[m] * g;\n            ort[m] = ort[m] - g;\n\n            for (j = m; j < n; j++) {\n                f = 0;\n                for (i = high; i >= m; i--) {\n                    f += ort[i] * H[i][j];\n                }\n\n                f = f / h;\n                for (i = m; i <= high; i++) {\n                    H[i][j] -= f * ort[i];\n                }\n            }\n\n            for (i = 0; i <= high; i++) {\n                f = 0;\n                for (j = high; j >= m; j--) {\n                    f += ort[j] * H[i][j];\n                }\n\n                f = f / h;\n                for (j = m; j <= high; j++) {\n                    H[i][j] -= f * ort[j];\n                }\n            }\n\n            ort[m] = scale * ort[m];\n            H[m][m - 1] = scale * g;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            V[i][j] = (i === j ? 1 : 0);\n        }\n    }\n\n    for (m = high - 1; m >= low + 1; m--) {\n        if (H[m][m - 1] !== 0) {\n            for (i = m + 1; i <= high; i++) {\n                ort[i] = H[i][m - 1];\n            }\n\n            for (j = m; j <= high; j++) {\n                g = 0;\n                for (i = m; i <= high; i++) {\n                    g += ort[i] * V[i][j];\n                }\n\n                g = (g / ort[m]) / H[m][m - 1];\n                for (i = m; i <= high; i++) {\n                    V[i][j] += g * ort[i];\n                }\n            }\n        }\n    }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n    var n = nn - 1,\n        low = 0,\n        high = nn - 1,\n        eps = Math.pow(2, -52),\n        exshift = 0,\n        norm = 0,\n        p = 0,\n        q = 0,\n        r = 0,\n        s = 0,\n        z = 0,\n        iter = 0,\n        i, j, k, l, m, t, w, x, y,\n        ra, sa, vr, vi,\n        notlast, cdivres;\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            d[i] = H[i][i];\n            e[i] = 0;\n        }\n\n        for (j = Math.max(i - 1, 0); j < nn; j++) {\n            norm = norm + Math.abs(H[i][j]);\n        }\n    }\n\n    while (n >= low) {\n        l = n;\n        while (l > low) {\n            s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\n            if (s === 0) {\n                s = norm;\n            }\n            if (Math.abs(H[l][l - 1]) < eps * s) {\n                break;\n            }\n            l--;\n        }\n\n        if (l === n) {\n            H[n][n] = H[n][n] + exshift;\n            d[n] = H[n][n];\n            e[n] = 0;\n            n--;\n            iter = 0;\n        } else if (l === n - 1) {\n            w = H[n][n - 1] * H[n - 1][n];\n            p = (H[n - 1][n - 1] - H[n][n]) / 2;\n            q = p * p + w;\n            z = Math.sqrt(Math.abs(q));\n            H[n][n] = H[n][n] + exshift;\n            H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\n            x = H[n][n];\n\n            if (q >= 0) {\n                z = (p >= 0) ? (p + z) : (p - z);\n                d[n - 1] = x + z;\n                d[n] = d[n - 1];\n                if (z !== 0) {\n                    d[n] = x - w / z;\n                }\n                e[n - 1] = 0;\n                e[n] = 0;\n                x = H[n][n - 1];\n                s = Math.abs(x) + Math.abs(z);\n                p = x / s;\n                q = z / s;\n                r = Math.sqrt(p * p + q * q);\n                p = p / r;\n                q = q / r;\n\n                for (j = n - 1; j < nn; j++) {\n                    z = H[n - 1][j];\n                    H[n - 1][j] = q * z + p * H[n][j];\n                    H[n][j] = q * H[n][j] - p * z;\n                }\n\n                for (i = 0; i <= n; i++) {\n                    z = H[i][n - 1];\n                    H[i][n - 1] = q * z + p * H[i][n];\n                    H[i][n] = q * H[i][n] - p * z;\n                }\n\n                for (i = low; i <= high; i++) {\n                    z = V[i][n - 1];\n                    V[i][n - 1] = q * z + p * V[i][n];\n                    V[i][n] = q * V[i][n] - p * z;\n                }\n            } else {\n                d[n - 1] = x + p;\n                d[n] = x + p;\n                e[n - 1] = z;\n                e[n] = -z;\n            }\n\n            n = n - 2;\n            iter = 0;\n        } else {\n            x = H[n][n];\n            y = 0;\n            w = 0;\n            if (l < n) {\n                y = H[n - 1][n - 1];\n                w = H[n][n - 1] * H[n - 1][n];\n            }\n\n            if (iter === 10) {\n                exshift += x;\n                for (i = low; i <= n; i++) {\n                    H[i][i] -= x;\n                }\n                s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\n                x = y = 0.75 * s;\n                w = -0.4375 * s * s;\n            }\n\n            if (iter === 30) {\n                s = (y - x) / 2;\n                s = s * s + w;\n                if (s > 0) {\n                    s = Math.sqrt(s);\n                    if (y < x) {\n                        s = -s;\n                    }\n                    s = x - w / ((y - x) / 2 + s);\n                    for (i = low; i <= n; i++) {\n                        H[i][i] -= s;\n                    }\n                    exshift += s;\n                    x = y = w = 0.964;\n                }\n            }\n\n            iter = iter + 1;\n\n            m = n - 2;\n            while (m >= l) {\n                z = H[m][m];\n                r = x - z;\n                s = y - z;\n                p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\n                q = H[m + 1][m + 1] - z - r - s;\n                r = H[m + 2][m + 1];\n                s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                p = p / s;\n                q = q / s;\n                r = r / s;\n                if (m === l) {\n                    break;\n                }\n                if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) + Math.abs(H[m + 1][m + 1])))) {\n                    break;\n                }\n                m--;\n            }\n\n            for (i = m + 2; i <= n; i++) {\n                H[i][i - 2] = 0;\n                if (i > m + 2) {\n                    H[i][i - 3] = 0;\n                }\n            }\n\n            for (k = m; k <= n - 1; k++) {\n                notlast = (k !== n - 1);\n                if (k !== m) {\n                    p = H[k][k - 1];\n                    q = H[k + 1][k - 1];\n                    r = (notlast ? H[k + 2][k - 1] : 0);\n                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n                    if (x !== 0) {\n                        p = p / x;\n                        q = q / x;\n                        r = r / x;\n                    }\n                }\n\n                if (x === 0) {\n                    break;\n                }\n\n                s = Math.sqrt(p * p + q * q + r * r);\n                if (p < 0) {\n                    s = -s;\n                }\n\n                if (s !== 0) {\n                    if (k !== m) {\n                        H[k][k - 1] = -s * x;\n                    } else if (l !== m) {\n                        H[k][k - 1] = -H[k][k - 1];\n                    }\n\n                    p = p + s;\n                    x = p / s;\n                    y = q / s;\n                    z = r / s;\n                    q = q / p;\n                    r = r / p;\n\n                    for (j = k; j < nn; j++) {\n                        p = H[k][j] + q * H[k + 1][j];\n                        if (notlast) {\n                            p = p + r * H[k + 2][j];\n                            H[k + 2][j] = H[k + 2][j] - p * z;\n                        }\n\n                        H[k][j] = H[k][j] - p * x;\n                        H[k + 1][j] = H[k + 1][j] - p * y;\n                    }\n\n                    for (i = 0; i <= Math.min(n, k + 3); i++) {\n                        p = x * H[i][k] + y * H[i][k + 1];\n                        if (notlast) {\n                            p = p + z * H[i][k + 2];\n                            H[i][k + 2] = H[i][k + 2] - p * r;\n                        }\n\n                        H[i][k] = H[i][k] - p;\n                        H[i][k + 1] = H[i][k + 1] - p * q;\n                    }\n\n                    for (i = low; i <= high; i++) {\n                        p = x * V[i][k] + y * V[i][k + 1];\n                        if (notlast) {\n                            p = p + z * V[i][k + 2];\n                            V[i][k + 2] = V[i][k + 2] - p * r;\n                        }\n\n                        V[i][k] = V[i][k] - p;\n                        V[i][k + 1] = V[i][k + 1] - p * q;\n                    }\n                }\n            }\n        }\n    }\n\n    if (norm === 0) {\n        return;\n    }\n\n    for (n = nn - 1; n >= 0; n--) {\n        p = d[n];\n        q = e[n];\n\n        if (q === 0) {\n            l = n;\n            H[n][n] = 1;\n            for (i = n - 1; i >= 0; i--) {\n                w = H[i][i] - p;\n                r = 0;\n                for (j = l; j <= n; j++) {\n                    r = r + H[i][j] * H[j][n];\n                }\n\n                if (e[i] < 0) {\n                    z = w;\n                    s = r;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        H[i][n] = (w !== 0) ? (-r / w) : (-r / (eps * norm));\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n                        t = (x * s - z * r) / q;\n                        H[i][n] = t;\n                        H[i + 1][n] = (Math.abs(x) > Math.abs(z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);\n                    }\n\n                    t = Math.abs(H[i][n]);\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        } else if (q < 0) {\n            l = n - 1;\n\n            if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\n                H[n - 1][n - 1] = q / H[n][n - 1];\n                H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\n            } else {\n                cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\n                H[n - 1][n - 1] = cdivres[0];\n                H[n - 1][n] = cdivres[1];\n            }\n\n            H[n][n - 1] = 0;\n            H[n][n] = 1;\n            for (i = n - 2; i >= 0; i--) {\n                ra = 0;\n                sa = 0;\n                for (j = l; j <= n; j++) {\n                    ra = ra + H[i][j] * H[j][n - 1];\n                    sa = sa + H[i][j] * H[j][n];\n                }\n\n                w = H[i][i] - p;\n\n                if (e[i] < 0) {\n                    z = w;\n                    r = ra;\n                    s = sa;\n                } else {\n                    l = i;\n                    if (e[i] === 0) {\n                        cdivres = cdiv(-ra, -sa, w, q);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                    } else {\n                        x = H[i][i + 1];\n                        y = H[i + 1][i];\n                        vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n                        vi = (d[i] - p) * 2 * q;\n                        if (vr === 0 && vi === 0) {\n                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x) + Math.abs(y) + Math.abs(z));\n                        }\n                        cdivres = cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);\n                        H[i][n - 1] = cdivres[0];\n                        H[i][n] = cdivres[1];\n                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {\n                            H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\n                            H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\n                        } else {\n                            cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\n                            H[i + 1][n - 1] = cdivres[0];\n                            H[i + 1][n] = cdivres[1];\n                        }\n                    }\n\n                    t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\n                    if ((eps * t) * t > 1) {\n                        for (j = i; j <= n; j++) {\n                            H[j][n - 1] = H[j][n - 1] / t;\n                            H[j][n] = H[j][n] / t;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < nn; i++) {\n        if (i < low || i > high) {\n            for (j = i; j < nn; j++) {\n                V[i][j] = H[i][j];\n            }\n        }\n    }\n\n    for (j = nn - 1; j >= low; j--) {\n        for (i = low; i <= high; i++) {\n            z = 0;\n            for (k = low; k <= Math.min(j, high); k++) {\n                z = z + V[i][k] * H[k][j];\n            }\n            V[i][j] = z;\n        }\n    }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n    var r, d;\n    if (Math.abs(yr) > Math.abs(yi)) {\n        r = yi / yr;\n        d = yr + r * yi;\n        return [(xr + r * xi) / d, (xi - r * xr) / d];\n    } else {\n        r = yr / yi;\n        d = yi + r * yr;\n        return [(r * xr + xi) / d, (r * xi - xr) / d];\n    }\n}\n\nmodule.exports = EigenvalueDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/evd.js\n// module id = 34\n// module chunks = 0","'use strict';\n\nvar Matrix = require('../matrix').Matrix;\nvar hypotenuse = require('./util').hypotenuse;\n\n//https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\nfunction QrDecomposition(value) {\n    if (!(this instanceof QrDecomposition)) {\n        return new QrDecomposition(value);\n    }\n    value = Matrix.checkMatrix(value);\n\n    var qr = value.clone(),\n        m = value.rows,\n        n = value.columns,\n        rdiag = new Array(n),\n        i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n        var nrm = 0;\n        for (i = k; i < m; i++) {\n            nrm = hypotenuse(nrm, qr[i][k]);\n        }\n        if (nrm !== 0) {\n            if (qr[k][k] < 0) {\n                nrm = -nrm;\n            }\n            for (i = k; i < m; i++) {\n                qr[i][k] /= nrm;\n            }\n            qr[k][k] += 1;\n            for (j = k + 1; j < n; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * qr[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    qr[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n}\n\nQrDecomposition.prototype = {\n    solve: function (value) {\n        value = Matrix.checkMatrix(value);\n\n        var qr = this.QR,\n            m = qr.rows;\n\n        if (value.rows !== m) {\n            throw new Error('Matrix row dimensions must agree');\n        }\n        if (!this.isFullRank()) {\n            throw new Error('Matrix is rank deficient');\n        }\n\n        var count = value.columns;\n        var X = value.clone();\n        var n = qr.columns;\n        var i, j, k, s;\n\n        for (k = 0; k < n; k++) {\n            for (j = 0; j < count; j++) {\n                s = 0;\n                for (i = k; i < m; i++) {\n                    s += qr[i][k] * X[i][j];\n                }\n                s = -s / qr[k][k];\n                for (i = k; i < m; i++) {\n                    X[i][j] += s * qr[i][k];\n                }\n            }\n        }\n        for (k = n - 1; k >= 0; k--) {\n            for (j = 0; j < count; j++) {\n                X[k][j] /= this.Rdiag[k];\n            }\n            for (i = 0; i < k; i++) {\n                for (j = 0; j < count; j++) {\n                    X[i][j] -= X[k][j] * qr[i][k];\n                }\n            }\n        }\n\n        return X.subMatrix(0, n - 1, 0, count - 1);\n    },\n    isFullRank: function () {\n        var columns = this.QR.columns;\n        for (var i = 0; i < columns; i++) {\n            if (this.Rdiag[i] === 0) {\n                return false;\n            }\n        }\n        return true;\n    },\n    get upperTriangularMatrix() {\n        var qr = this.QR,\n            n = qr.columns,\n            X = new Matrix(n, n),\n            i, j;\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                if (i < j) {\n                    X[i][j] = qr[i][j];\n                } else if (i === j) {\n                    X[i][j] = this.Rdiag[i];\n                } else {\n                    X[i][j] = 0;\n                }\n            }\n        }\n        return X;\n    },\n    get orthogonalMatrix() {\n        var qr = this.QR,\n            rows = qr.rows,\n            columns = qr.columns,\n            X = new Matrix(rows, columns),\n            i, j, k, s;\n\n        for (k = columns - 1; k >= 0; k--) {\n            for (i = 0; i < rows; i++) {\n                X[i][k] = 0;\n            }\n            X[k][k] = 1;\n            for (j = k; j < columns; j++) {\n                if (qr[k][k] !== 0) {\n                    s = 0;\n                    for (i = k; i < rows; i++) {\n                        s += qr[i][k] * X[i][j];\n                    }\n\n                    s = -s / qr[k][k];\n\n                    for (i = k; i < rows; i++) {\n                        X[i][j] += s * qr[i][k];\n                    }\n                }\n            }\n        }\n        return X;\n    }\n};\n\nmodule.exports = QrDecomposition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/dc/qr.js\n// module id = 35\n// module chunks = 0","'use strict';\n\nvar Matrix = require('./matrix').Matrix;\n\nvar SingularValueDecomposition = require('./dc/svd');\nvar EigenvalueDecomposition = require('./dc/evd');\nvar LuDecomposition = require('./dc/lu');\nvar QrDecomposition = require('./dc/qr');\nvar CholeskyDecomposition = require('./dc/cholesky');\n\nfunction inverse(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    return solve(matrix, Matrix.eye(matrix.rows));\n}\n\n/**\n * Returns the inverse\n * @memberOf Matrix\n * @static\n * @param {Matrix} matrix\n * @return {Matrix} matrix\n * @alias inv\n */\nMatrix.inverse = Matrix.inv = inverse;\n\n/**\n * Returns the inverse\n * @memberOf Matrix\n * @static\n * @param {Matrix} matrix\n * @return {Matrix} matrix\n * @alias inv\n */\nMatrix.prototype.inverse = Matrix.prototype.inv = function () {\n    return inverse(this);\n};\n\nfunction solve(leftHandSide, rightHandSide) {\n    leftHandSide = Matrix.checkMatrix(leftHandSide);\n    rightHandSide = Matrix.checkMatrix(rightHandSide);\n    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);\n}\n\nMatrix.solve = solve;\nMatrix.prototype.solve = function (other) {\n    return solve(this, other);\n};\n\nmodule.exports = {\n    SingularValueDecomposition: SingularValueDecomposition,\n    SVD: SingularValueDecomposition,\n    EigenvalueDecomposition: EigenvalueDecomposition,\n    EVD: EigenvalueDecomposition,\n    LuDecomposition: LuDecomposition,\n    LU: LuDecomposition,\n    QrDecomposition: QrDecomposition,\n    QR: QrDecomposition,\n    CholeskyDecomposition: CholeskyDecomposition,\n    CHO: CholeskyDecomposition,\n    inverse: inverse,\n    solve: solve\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/decompositions.js\n// module id = 36\n// module chunks = 0","'use strict';\n\nif (!Symbol.species) {\n    Symbol.species = Symbol.for('@@species');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/symbol-species.js\n// module id = 37\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixColumnView extends BaseView {\n    constructor(matrix, column) {\n        super(matrix, matrix.rows, 1);\n        this.column = column;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(rowIndex, this.column, value);\n        return this;\n    }\n\n    get(rowIndex) {\n        return this.matrix.get(rowIndex, this.column);\n    }\n}\n\nmodule.exports = MatrixColumnView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/column.js\n// module id = 38\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixFlipColumnView extends BaseView {\n    constructor(matrix) {\n        super(matrix, matrix.rows, matrix.columns);\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);\n    }\n}\n\nmodule.exports = MatrixFlipColumnView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/flipColumn.js\n// module id = 39\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixFlipRowView extends BaseView {\n    constructor(matrix) {\n        super(matrix, matrix.rows, matrix.columns);\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);\n    }\n}\n\nmodule.exports = MatrixFlipRowView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/flipRow.js\n// module id = 40\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixRowView extends BaseView {\n    constructor(matrix, row) {\n        super(matrix, 1, matrix.columns);\n        this.row = row;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.row, columnIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.row, columnIndex);\n    }\n}\n\nmodule.exports = MatrixRowView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/row.js\n// module id = 41\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\nvar util = require('../util');\n\nclass MatrixSelectionView extends BaseView {\n    constructor(matrix, rowIndices, columnIndices) {\n        var indices = util.checkIndices(matrix, rowIndices, columnIndices);\n        super(matrix, indices.row.length, indices.column.length);\n        this.rowIndices = indices.row;\n        this.columnIndices = indices.column;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.rowIndices[rowIndex], this.columnIndices[columnIndex], value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.rowIndices[rowIndex], this.columnIndices[columnIndex]);\n    }\n}\n\nmodule.exports = MatrixSelectionView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/selection.js\n// module id = 42\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\nvar util = require('../util');\n\nclass MatrixSubView extends BaseView {\n    constructor(matrix, startRow, endRow, startColumn, endColumn) {\n        util.checkRange(matrix, startRow, endRow, startColumn, endColumn);\n        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);\n        this.startRow = startRow;\n        this.startColumn = startColumn;\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(this.startRow + rowIndex, this.startColumn + columnIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(this.startRow + rowIndex, this.startColumn + columnIndex);\n    }\n}\n\nmodule.exports = MatrixSubView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/sub.js\n// module id = 43\n// module chunks = 0","'use strict';\n\nvar BaseView = require('./base');\n\nclass MatrixTransposeView extends BaseView {\n    constructor(matrix) {\n        super(matrix, matrix.columns, matrix.rows);\n    }\n\n    set(rowIndex, columnIndex, value) {\n        this.matrix.set(columnIndex, rowIndex, value);\n        return this;\n    }\n\n    get(rowIndex, columnIndex) {\n        return this.matrix.get(columnIndex, rowIndex);\n    }\n}\n\nmodule.exports = MatrixTransposeView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-matrix/src/views/transpose.js\n// module id = 44\n// module chunks = 0","'use strict';\n\nvar arrayStat = require('./array');\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\nexports.max = function max(matrix) {\n    var max = -Infinity;\n    for (var i = 0; i < matrix.length; i++) {\n        for (var j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] > max) max = matrix[i][j];\n        }\n    }\n    return max;\n};\n\nexports.min = function min(matrix) {\n    var min = Infinity;\n    for (var i = 0; i < matrix.length; i++) {\n        for (var j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] < min) min = matrix[i][j];\n        }\n    }\n    return min;\n};\n\nexports.minMax = function minMax(matrix) {\n    var min = Infinity;\n    var max = -Infinity;\n    for (var i = 0; i < matrix.length; i++) {\n        for (var j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] < min) min = matrix[i][j];\n            if (matrix[i][j] > max) max = matrix[i][j];\n        }\n    }\n    return {\n        min:min,\n        max:max\n    };\n};\n\nexports.entropy = function entropy(matrix, eps) {\n    if (typeof (eps) === 'undefined') {\n        eps = 0;\n    }\n    var sum = 0,\n        l1 = matrix.length,\n        l2 = matrix[0].length;\n    for (var i = 0; i < l1; i++) {\n        for (var j = 0; j < l2; j++) {\n            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);\n        }\n    }\n    return -sum;\n};\n\nexports.mean = function mean(matrix, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theMean, N, i, j;\n\n    if (dimension === -1) {\n        theMean = [0];\n        N = rows * cols;\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theMean[0] += matrix[i][j];\n            }\n        }\n        theMean[0] /= N;\n    } else if (dimension === 0) {\n        theMean = new Array(cols);\n        N = rows;\n        for (j = 0; j < cols; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < rows; i++) {\n                theMean[j] += matrix[i][j];\n            }\n            theMean[j] /= N;\n        }\n    } else if (dimension === 1) {\n        theMean = new Array(rows);\n        N = cols;\n        for (j = 0; j < rows; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < cols; i++) {\n                theMean[j] += matrix[j][i];\n            }\n            theMean[j] /= N;\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theMean;\n};\n\nexports.sum = function sum(matrix, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theSum, i, j;\n\n    if (dimension === -1) {\n        theSum = [0];\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theSum[0] += matrix[i][j];\n            }\n        }\n    } else if (dimension === 0) {\n        theSum = new Array(cols);\n        for (j = 0; j < cols; j++) {\n            theSum[j] = 0;\n            for (i = 0; i < rows; i++) {\n                theSum[j] += matrix[i][j];\n            }\n        }\n    } else if (dimension === 1) {\n        theSum = new Array(rows);\n        for (j = 0; j < rows; j++) {\n            theSum[j] = 0;\n            for (i = 0; i < cols; i++) {\n                theSum[j] += matrix[j][i];\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theSum;\n};\n\nexports.product = function product(matrix, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theProduct, i, j;\n\n    if (dimension === -1) {\n        theProduct = [1];\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theProduct[0] *= matrix[i][j];\n            }\n        }\n    } else if (dimension === 0) {\n        theProduct = new Array(cols);\n        for (j = 0; j < cols; j++) {\n            theProduct[j] = 1;\n            for (i = 0; i < rows; i++) {\n                theProduct[j] *= matrix[i][j];\n            }\n        }\n    } else if (dimension === 1) {\n        theProduct = new Array(rows);\n        for (j = 0; j < rows; j++) {\n            theProduct[j] = 1;\n            for (i = 0; i < cols; i++) {\n                theProduct[j] *= matrix[j][i];\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theProduct;\n};\n\nexports.standardDeviation = function standardDeviation(matrix, means, unbiased) {\n    var vari = exports.variance(matrix, means, unbiased), l = vari.length;\n    for (var i = 0; i < l; i++) {\n        vari[i] = Math.sqrt(vari[i]);\n    }\n    return vari;\n};\n\nexports.variance = function variance(matrix, means, unbiased) {\n    if (typeof (unbiased) === 'undefined') {\n        unbiased = true;\n    }\n    means = means || exports.mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum1 = 0, sum2 = 0, x = 0;\n        for (var i = 0; i < rows; i++) {\n            x = matrix[i][j] - means[j];\n            sum1 += x;\n            sum2 += x * x;\n        }\n        if (unbiased) {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);\n        } else {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;\n        }\n    }\n    return vari;\n};\n\nexports.median = function median(matrix) {\n    var rows = matrix.length, cols = matrix[0].length;\n    var medians = new Array(cols);\n\n    for (var i = 0; i < cols; i++) {\n        var data = new Array(rows);\n        for (var j = 0; j < rows; j++) {\n            data[j] = matrix[j][i];\n        }\n        data.sort(compareNumbers);\n        var N = data.length;\n        if (N % 2 === 0) {\n            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;\n        } else {\n            medians[i] = data[Math.floor(N / 2)];\n        }\n    }\n    return medians;\n};\n\nexports.mode = function mode(matrix) {\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        modes = new Array(cols),\n        i, j;\n    for (i = 0; i < cols; i++) {\n        var itemCount = new Array(rows);\n        for (var k = 0; k < rows; k++) {\n            itemCount[k] = 0;\n        }\n        var itemArray = new Array(rows);\n        var count = 0;\n\n        for (j = 0; j < rows; j++) {\n            var index = itemArray.indexOf(matrix[j][i]);\n            if (index >= 0) {\n                itemCount[index]++;\n            } else {\n                itemArray[count] = matrix[j][i];\n                itemCount[count] = 1;\n                count++;\n            }\n        }\n\n        var maxValue = 0, maxIndex = 0;\n        for (j = 0; j < count; j++) {\n            if (itemCount[j] > maxValue) {\n                maxValue = itemCount[j];\n                maxIndex = j;\n            }\n        }\n\n        modes[i] = itemArray[maxIndex];\n    }\n    return modes;\n};\n\nexports.skewness = function skewness(matrix, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var means = exports.mean(matrix);\n    var n = matrix.length, l = means.length;\n    var skew = new Array(l);\n\n    for (var j = 0; j < l; j++) {\n        var s2 = 0, s3 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s3 += dev * dev * dev;\n        }\n\n        var m2 = s2 / n;\n        var m3 = s3 / n;\n        var g = m3 / Math.pow(m2, 3 / 2);\n\n        if (unbiased) {\n            var a = Math.sqrt(n * (n - 1));\n            var b = n - 2;\n            skew[j] = (a / b) * g;\n        } else {\n            skew[j] = g;\n        }\n    }\n    return skew;\n};\n\nexports.kurtosis = function kurtosis(matrix, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var means = exports.mean(matrix);\n    var n = matrix.length, m = matrix[0].length;\n    var kurt = new Array(m);\n\n    for (var j = 0; j < m; j++) {\n        var s2 = 0, s4 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s4 += dev * dev * dev * dev;\n        }\n        var m2 = s2 / n;\n        var m4 = s4 / n;\n\n        if (unbiased) {\n            var v = s2 / (n - 1);\n            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n            var b = s4 / (v * v);\n            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n            kurt[j] = a * b - 3 * c;\n        } else {\n            kurt[j] = m4 / (m2 * m2) - 3;\n        }\n    }\n    return kurt;\n};\n\nexports.standardError = function standardError(matrix) {\n    var samples = matrix.length;\n    var standardDeviations = exports.standardDeviation(matrix);\n    var l = standardDeviations.length;\n    var standardErrors = new Array(l);\n    var sqrtN = Math.sqrt(samples);\n\n    for (var i = 0; i < l; i++) {\n        standardErrors[i] = standardDeviations[i] / sqrtN;\n    }\n    return standardErrors;\n};\n\nexports.covariance = function covariance(matrix, dimension) {\n    return exports.scatter(matrix, undefined, dimension);\n};\n\nexports.scatter = function scatter(matrix, divisor, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    if (typeof (divisor) === 'undefined') {\n        if (dimension === 0) {\n            divisor = matrix.length - 1;\n        } else if (dimension === 1) {\n            divisor = matrix[0].length - 1;\n        }\n    }\n    var means = exports.mean(matrix, dimension);\n    var rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, s, k;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n};\n\nexports.correlation = function correlation(matrix) {\n    var means = exports.mean(matrix),\n        standardDeviations = exports.standardDeviation(matrix, true, means),\n        scores = exports.zScores(matrix, means, standardDeviations),\n        rows = matrix.length,\n        cols = matrix[0].length,\n        i, j;\n\n    var cor = new Array(cols);\n    for (i = 0; i < cols; i++) {\n        cor[i] = new Array(cols);\n    }\n    for (i = 0; i < cols; i++) {\n        for (j = i; j < cols; j++) {\n            var c = 0;\n            for (var k = 0, l = scores.length; k < l; k++) {\n                c += scores[k][j] * scores[k][i];\n            }\n            c /= rows - 1;\n            cor[i][j] = c;\n            cor[j][i] = c;\n        }\n    }\n    return cor;\n};\n\nexports.zScores = function zScores(matrix, means, standardDeviations) {\n    means = means || exports.mean(matrix);\n    if (typeof (standardDeviations) === 'undefined') standardDeviations = exports.standardDeviation(matrix, true, means);\n    return exports.standardize(exports.center(matrix, means, false), standardDeviations, true);\n};\n\nexports.center = function center(matrix, means, inPlace) {\n    means = means || exports.mean(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var row = result[i];\n        for (j = 0, jj = row.length; j < jj; j++) {\n            row[j] = matrix[i][j] - means[j];\n        }\n    }\n    return result;\n};\n\nexports.standardize = function standardize(matrix, standardDeviations, inPlace) {\n    if (typeof (standardDeviations) === 'undefined') standardDeviations = exports.standardDeviation(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var resultRow = result[i];\n        var sourceRow = matrix[i];\n        for (j = 0, jj = resultRow.length; j < jj; j++) {\n            if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {\n                resultRow[j] = sourceRow[j] / standardDeviations[j];\n            }\n        }\n    }\n    return result;\n};\n\nexports.weightedVariance = function weightedVariance(matrix, weights) {\n    var means = exports.mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum = 0;\n        var a = 0, b = 0;\n\n        for (var i = 0; i < rows; i++) {\n            var z = matrix[i][j] - means[j];\n            var w = weights[i];\n\n            sum += w * (z * z);\n            b += w;\n            a += w * w;\n        }\n\n        vari[j] = sum * (b / (b * b - a));\n    }\n\n    return vari;\n};\n\nexports.weightedMean = function weightedMean(matrix, weights, dimension) {\n    if (typeof (dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length,\n        means, i, ii, j, w, row;\n\n    if (dimension === 0) {\n        means = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            means[i] = 0;\n        }\n        for (i = 0; i < rows; i++) {\n            row = matrix[i];\n            w = weights[i];\n            for (j = 0; j < cols; j++) {\n                means[j] += row[j] * w;\n            }\n        }\n    } else if (dimension === 1) {\n        means = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            means[i] = 0;\n        }\n        for (j = 0; j < rows; j++) {\n            row = matrix[j];\n            w = weights[j];\n            for (i = 0; i < cols; i++) {\n                means[j] += row[i] * w;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    var weightSum = arrayStat.sum(weights);\n    if (weightSum !== 0) {\n        for (i = 0, ii = means.length; i < ii; i++) {\n            means[i] /= weightSum;\n        }\n    }\n    return means;\n};\n\nexports.weightedCovariance = function weightedCovariance(matrix, weights, means, dimension) {\n    dimension = dimension || 0;\n    means = means || exports.weightedMean(matrix, weights, dimension);\n    var s1 = 0, s2 = 0;\n    for (var i = 0, ii = weights.length; i < ii; i++) {\n        s1 += weights[i];\n        s2 += weights[i] * weights[i];\n    }\n    var factor = s1 / (s1 * s1 - s2);\n    return exports.weightedScatter(matrix, weights, means, factor, dimension);\n};\n\nexports.weightedScatter = function weightedScatter(matrix, weights, means, factor, dimension) {\n    dimension = dimension || 0;\n    means = means || exports.weightedMean(matrix, weights, dimension);\n    if (typeof (factor) === 'undefined') {\n        factor = 1;\n    }\n    var rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, k, s;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ml-stat/matrix.js\n// module id = 45\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ms/index.js\n// module id = 46\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 47\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 48\n// module chunks = 0"],"sourceRoot":""}